<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benchmark Plotter</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg width%3D%2232%22 height%3D%2232%22 viewBox%3D%220 0 32 32%22 xmlns%3D%22http%3A//www.w3.org/2000/svg%22%3E %3Crect width%3D%2232%22 height%3D%2232%22 fill%3D%22white%22/%3E %3Ccircle cx%3D%228%22 cy%3D%2224%22 r%3D%223%22 fill%3D%22%235D5CDE%22/%3E %3Ccircle cx%3D%2214%22 cy%3D%2218%22 r%3D%223%22 fill%3D%22%235D5CDE%22/%3E %3Ccircle cx%3D%2220%22 cy%3D%2214%22 r%3D%223%22 fill%3D%22%235D5CDE%22/%3E %3Ccircle cx%3D%2226%22 cy%3D%225%22 r%3D%223%22 fill%3D%22%235D5CDE%22/%3E %3Cline x1%3D%224%22 y1%3D%2228%22 x2%3D%2228%22 y2%3D%224%22 opacity%3D%220.3%22 stroke%3D%22%232B42FF%22 stroke-width%3D%221%22/%3E %3C/svg%3E" type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/tailwindcss-cdn@3.4.10/tailwindcss.js" integrity="sha384-cqoPWRPexlPol6Nnsc9Gt050DVIPQMSL4jB2ufKvIBxN7mo6FoC439ixYPCAAPq7" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" integrity="sha384-9MhbyIRcBVQiiC7FSd7T38oJNj2Zh+EfxS7/vjhBi4OOT78NlHSnzM31EZRWR1LZ" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js" integrity="sha384-Crp3O/636k0LjUK6uxSF2i5herKUb8UIA16lRYz/PGAlkuavAVGFH5v2YlBayW8d" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-trendline@1.0.2/dist/chartjs-plugin-trendline.min.js" integrity="sha384-tsC84Be07it4JHRYapRUjF4lL6JhG4mJO2Z+qN0GNU9nx1aBPh/92VfiWwLdbdoj" crossorigin="anonymous"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            },
            darkMode: 'class'
        }
    </script>
    <style>
    /**** All these styles are for improving the UX of the expandable table ****/

        /* Component wrapper */
        .truncated-table-container {
            position: relative; /* Needed for absolute positioning of overlay */
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); /* shadow-sm */
            /* overflow: hidden; */ /* Shouldn't be needed unless the shadow doesn't clip correctly */
            margin-bottom: 4rem; /* Make room for the button */
        }

        /* Table wrapper for controlling height */
        .table-container {
            overflow: hidden;
            /* Initial collapsed height - adjust as needed */
            max-height: 240px; /* approx 6 rows + header */
            transition: max-height 0.5s ease-in-out;
        }

        /* Style for when the table is expanded */
        .table-container.is-expanded {
            /* Override the less specific CSS rule that only applies to one class, .table-container */
            max-height: none; /* Don't assume there is a maximum size a table can be */
        }
    
        /* Fade overlay */
        .fade-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6rem; /* 96px - Adjust height of fade */
            /* Gradient from transparent to page background color */
            background: linear-gradient(to top, #f9fafb, rgba(249, 250, 251, 0.8), transparent);
            pointer-events: none; /* Allow clicks to pass through */
            transition: opacity 0.3s ease-out;
            opacity: 1; /* Visible by default */
        }

        /* Dark mode fade overlay */
        .dark .fade-overlay {
            background: linear-gradient(to top, rgb(17, 24, 39), rgba(17, 24, 39, 0.8), transparent);
        }

        /* Button container */
        .button-container {
            position: absolute;
            bottom: 0.5rem; /* 8px - Position button slightly up from the bottom */
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto; /* Make this specific area clickable */
            z-index: 20; /* Ensure button is above the fade */
            margin-bottom: -3rem; /* Ensure the button doesn't overlap the table content */
        }

        /* Toggle button styling */
        .toggle-button {
            background-color: #ffffff; /* white */
            border-radius: 9999px; /* rounded-full */
            padding: 0.5rem; /* p-2 */
            border: 1px solid #e5e7eb; /* gray-200 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            cursor: pointer;
            display: flex; /* Align icon */
            align-items: center;
            justify-content: center;
            color: #4b5563; /* gray-600 */
            transition: background-color 0.2s ease;
        }

        /* Dark mode toggle button */
        .dark .toggle-button {
            background-color: #1f2937; /* dark:bg-gray-800 */
            border-color: #374151; /* dark:border-gray-700 */
            color: #d1d5db; /* dark:text-gray-300 */
        }

        .toggle-button:hover {
            background-color: #f3f4f6; /* gray-100 */
            color: #111827; /* gray-900 */
        }

        .dark .toggle-button:hover {
            background-color: #374151; /* dark:bg-gray-700 */
            color: #f9fafb; /* dark:text-gray-100 */
        }

        .toggle-button:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5); /* Example focus ring (indigo-500) */
        }

        /* Icon styling */
        .toggle-button svg {
            width: 1.5rem; /* h-6 w-6 */
            height: 1.5rem;
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            background-color: #ef4444;
            color: white;
            border-radius: 0.375rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 50;
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }
        
        .toast.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* Chart container styles */
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin-top: 2rem;
            margin-bottom: 2rem;
            border-radius: 0.375rem;
            border: 1px solid #e5e7eb;
            background-color: white;
            padding: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        
        .dark .chart-container {
            background-color: #1f2937;
            border-color: #374151;
        }
        
        /* Custom CSS for expanding the child element (.menu-item-extra)
           when its parent's sibling radio (.menu-radio.peer) is checked.
           Tailwind's peer utilities are great for direct siblings, but for
           styling a child of that sibling based on the peer's state,
           a small custom rule is often the cleanest approach. */
        .menu-radio:checked + .menu-label .menu-item-extra {
            max-height: 8rem; /* Equivalent to Tailwind's max-h-32, adjust if needed */
            opacity: 1;
            margin-top: 0.5rem; /* Equivalent to Tailwind's mt-2 */
        }
        
        abbr {
            text-underline-offset: 2px;
        }
        
        /* --- Sortable Table Styles --- */
        
        .sortable th {
            cursor: ns-resize;
            position: relative;
            padding-right: 20px; /* Make room for sort indicator */
        }
        
        /* Non-sortable tables should have normal cursor */
        table:not(.sortable) th {
            cursor: default;
        }
        
        .sortable th::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.5;
        }
        
        .sortable th.sort-asc::after {
            content: "↑";
            opacity: 1;
        }
        
        .sortable th.sort-desc::after {
            content: "↓";
            opacity: 1;
        }

        /* --- Custom CSS for Sidebar Element Visibility --- */

        /* Chevron Icon Rotation */
        #sidebar-toggle:checked ~ aside label[for="sidebar-toggle"] > svg {
            transform: rotate(180deg);
        }

        /* "My App" Title Styling */
        /* Tailwind classes handle initial opacity, transitions, overflow */
        /* No specific default styles needed here unless overriding Tailwind */

        #sidebar-toggle:checked ~ aside .sidebar-app-title {
            opacity: 0;
            width: 0;
            /* Height and margin can also be set to 0 if needed for a more complete collapse,
               but width: 0 and overflow:hidden usually suffice with whitespace-nowrap. */
        }

        /* Navigation Text Styling */
        /* Tailwind classes handle initial opacity, transitions, overflow */
        #sidebar-toggle:checked ~ aside .sidebar-nav-text {
            opacity: 0;
            width: 0;
            height: 0;
            /* Adding margin/padding zeroing if space-x from parent is an issue */
            margin-left: 0;
            margin-right: 0;
            padding-left: 0;
            padding-right: 0;
        }
    </style>
</head>
<body class="m-0 min-h-screen bg-gray-100 dark:bg-gray-900">

    <input type="checkbox" id="sidebar-toggle" class="peer sr-only" />

    <aside class="w-80 bg-gray-800 p-5 text-white shadow-lg transition-all duration-300 ease-in-out fixed top-0 left-0 h-full overflow-y-auto sidebar-scroll peer-checked:w-20 peer-checked:p-2 z-20">
        
        <div class="flex items-center justify-between h-16 border-b border-slate-700 pb-4 mb-4">
            <div class="flex-grow overflow-hidden">
                <input type="radio" name="menu-selection" id="item0" class="menu-radio hidden peer" checked>
                <h2 class="text-xl font-semibold whitespace-nowrap overflow-hidden transition-all duration-300 ease-in-out sidebar-app-title">
                    <label for="item0" class="cursor-pointer block">Benchmarks</label>
                </h2>
            </div>
        
            <label for="sidebar-toggle" class="cursor-pointer p-2 rounded-md hover:bg-slate-700 transition-colors flex-shrink-0">
                <svg class="w-5 h-5 ml-4 mr-4 text-slate-300 hover:text-white transition-transform duration-300 ease-in-out transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </label>
        </div>
            
        <ul class="space-y-2">
            <li class="sidebar-nav-text hidden">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-PLACEHOLDER" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-PLACEHOLDER"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">NAME OF THE BENCHMARK</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://REPLACE-THIS.example.com/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: YYYY-MM-DD
                    </span>
                    <textarea class="hidden">
PASTE THE CSV DATA HERE
FILL IN THE NAME OF THE BENCHMARK, THE URL, AND THE DATE
PICK A SHORT ALPHANUMERIC NAME TO USE INSTEAD OF PLACEHOLDER
REMOVE THE "hidden" CLASS ON THE LIST ITEM (BUT LEAVE THE TEXTAREA HIDDEN)
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-aider" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-aider"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Aider Polyglot</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://aider.chat/docs/leaderboards/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-27
                    </span>
                    <textarea class="hidden">
Model,Release Date,Percent correct,Cost,Command,Correct edit format,Edit Format
gemini-2.5-pro-preview-06-05 (32k think),2025-06-05,83.1%,$49.88,aider --model gemini/gemini-2.5-pro-preview-06-05 --thinking-tokens 32k,99.6%,diff-fenced
o3 (high),2025-04-16,81.3%,$21.23,aider --model o3 --reasoning-effort high,94.7%,diff
gemini-2.5-pro-preview-06-05 (default think),2025-06-05,79.1%,$45.6,aider --model gemini/gemini-2.5-pro-preview-06-05,100.0%,diff-fenced
o3 (high) + gpt-4.1,2025-04-16,78.2%,$17.55,aider --model o3,100.0%,architect
o3,2025-04-16,76.9%,$13.75,aider --model o3,93.8%,diff
Gemini 2.5 Pro Preview 05-06,2025-06-05,76.9%,$37.41,aider --model gemini/gemini-2.5-pro-preview-05-06,97.3%,diff-fenced
Gemini 2.5 Pro Preview 03-25,2025-03-25,72.9%,,aider --model gemini/gemini-2.5-pro-preview-03-25,92.4%,diff-fenced
claude-opus-4-20250514 (32k thinking),2025-05-22,72.0%,$65.75,aider --model claude-opus-4-20250514,97.3%,diff
o4-mini (high),2025-04-16,72.0%,$19.64,aider --model o4-mini,90.7%,diff
DeepSeek R1 (0528),2025-05-28,71.4%,$4.8,aider --model deepseek/deepseek-reasoner,94.6%,diff
claude-opus-4-20250514 (no think),2025-05-22,70.7%,$68.63,aider --model claude-opus-4-20250514,98.7%,diff
claude-3-7-sonnet-20250219 (32k thinking tokens),2025-02-24,64.9%,$36.83,aider --model anthropic/claude-3-7-sonnet-20250219 --thinking-tokens 32k,97.8%,diff
DeepSeek R1 + claude-3-5-sonnet-20241022,2025-01-20,64.0%,$13.29,aider --architect --model r1 --editor-model sonnet,100.0%,architect
o1-2024-12-17 (high),2024-12-17,61.7%,$186.5,aider --model openrouter/openai/o1,91.5%,diff
claude-sonnet-4-20250514 (32k thinking),2025-05-22,61.3%,$26.58,aider --model claude-sonnet-4-20250514,97.3%,diff
claude-3-7-sonnet-20250219 (no thinking),2025-02-24,60.4%,$17.72,aider --model sonnet,93.3%,diff
o3-mini (high),2025-01-31,60.4%,$18.16,aider --model o3-mini --reasoning-effort high,93.3%,diff
"Qwen3 235B A22B diff, no think, Alibaba API",2025-04-29,59.6%,,aider --model openai/qwen3-235b-a22b,92.9%,diff
DeepSeek R1,2025-01-20,56.9%,$5.42,aider --model deepseek/deepseek-reasoner,96.9%,diff
claude-sonnet-4-20250514 (no thinking),2025-05-22,56.4%,$15.82,aider --model claude-sonnet-4-20250514,98.2%,diff
gemini-2.5-flash-preview-05-20 (24k think),2025-05-20,55.1%,$8.56,aider --model gemini/gemini-2.5-flash-preview-05-20,95.6%,diff
DeepSeek V3 (0324),2024-12-26,55.1%,$1.12,aider --model deepseek/deepseek-chat,99.6%,diff
Quasar Alpha,,54.7%,,aider --model openrouter/openrouter/quasar-alpha,98.2%,diff
o3-mini (medium),2025-01-31,53.8%,$8.86,aider --model o3-mini,95.1%,diff
Grok 3 Beta,2025-02-17,53.3%,$11.03,aider --model openrouter/x-ai/grok-3-beta,99.6%,diff
Optimus Alpha,,52.9%,,aider --model openrouter/openrouter/optimus-alpha,97.3%,diff
gpt-4.1,2025-04-14,52.4%,$9.86,aider --model gpt-4.1,98.2%,diff
claude-3-5-sonnet-20241022,2024-10-22,51.6%,$14.41,aider --model claude-3-5-sonnet-20241022,99.6%,diff
Grok 3 Mini Beta (high),2025-02-17,49.3%,$0.73,aider --model xai/grok-3-mini-beta --reasoning-effort high,99.6%,whole
DeepSeek Chat V3 (prev),2024-12-26,48.4%,$0.34,aider --model deepseek/deepseek-chat,98.7%,diff
gemini-2.5-flash-preview-04-17 (default),2025-04-17,47.1%,$1.85,aider --model gemini/gemini-2.5-flash-preview-04-17,85.3%,diff
chatgpt-4o-latest (2025-03-29),2025-03-29,45.3%,$19.74,aider --model chatgpt-4o-latest,64.4%,diff
gpt-4.5-preview,2025-02-27,44.9%,$183.18,aider --model openai/gpt-4.5-preview,97.3%,diff
gemini-2.5-flash-preview-05-20 (no think),2025-05-20,44.0%,$1.14,aider --model gemini/gemini-2.5-flash-preview-05-20,93.8%,diff
Qwen3 32B,2025-04-29,40.0%,$0.76,aider --model openrouter/qwen/qwen3-32b,83.6%,diff
gemini-exp-1206,2024-12-17,38.2%,,aider --model gemini/gemini-exp-1206,98.2%,whole
Gemini 2.0 Pro exp-02-05,2025-02-05,35.6%,,aider --model gemini/gemini-2.0-pro-exp-02-05,100.0%,whole
Grok 3 Mini Beta (low),2025-02-17,34.7%,$0.79,aider --model openrouter/x-ai/grok-3-mini-beta,100.0%,whole
o1-mini-2024-09-12,2024-09-12,32.9%,$18.58,aider --model o1-mini,96.9%,whole
gpt-4.1-mini,2025-04-14,32.4%,$1.99,aider --model gpt-4.1-mini,92.4%,diff
claude-3-5-haiku-20241022,2024-10-22,28.0%,$6.06,aider --model claude-3-5-haiku-20241022,91.1%,diff
chatgpt-4o-latest (2025-02-15),2025-02-15,27.1%,$14.37,aider --model chatgpt-4o-latest,93.3%,diff
QwQ-32B + Qwen 2.5 Coder Instruct,2024-09-19,26.2%,,aider --model fireworks_ai/accounts/fireworks/models/qwq-32b --architect,100.0%,architect
gpt-4o-2024-08-06,2024-08-06,23.1%,$7.03,aider --model gpt-4o-2024-08-06,94.2%,diff
gemini-2.0-flash-exp,2024-12-11,22.2%,,aider --model gemini/gemini-2.0-flash-exp,100.0%,whole
qwen-max-2025-01-25,2025-01-29,21.8%,,OPENAI_API_BASE=https://dashscope-intl.aliyuncs.com/compatible-mode/v1 aider --model openai/qwen-max-2025-01-25,90.2%,diff
QwQ-32B,2025-03-05,20.9%,,aider --model fireworks_ai/accounts/fireworks/models/qwq-32b,67.6%,diff
gemini-2.0-flash-thinking-exp-01-21,2025-01-21,18.2%,,aider --model gemini/gemini-2.0-flash-thinking-exp-01-21,77.8%,diff
gpt-4o-2024-11-20,2024-11-20,18.2%,$6.74,aider --model gpt-4o-2024-11-20,95.1%,diff
DeepSeek Chat V2.5,2024-09-05,17.8%,$0.51,aider --model deepseek/deepseek-chat,92.9%,diff
Qwen2.5-Coder-32B-Instruct,2024-09-19,16.4%,,aider --model openai/Qwen2.5-Coder-32B-Instruct,99.6%,whole
Llama 4 Maverick,2025-04-05,15.6%,,aider --model nvidia_nim/meta/llama-4-maverick-17b-128e-instruct,99.1%,whole
yi-lightning,,12.9%,,aider --model openai/yi-lightning,92.9%,whole
command-a-03-2025-quality,2025-03-13,12.0%,,OPENAI_API_BASE=https://api.cohere.ai/compatibility/v1 aider --model openai/command-a-03-2025-quality,99.6%,whole
Codestral 25.01,2025-01-13,11.1%,$1.98,aider --model mistral/codestral-latest,100.0%,whole
openhands-lm-32b-v0.1,,10.2%,,aider --model openrouter/all-hands/openhands-lm-32b-v0.1,95.1%,whole
gpt-4.1-nano,2025-04-14,8.9%,$0.43,aider --model gpt-4.1-nano,94.2%,whole
Qwen2.5-Coder-32B-Instruct,2024-09-19,8.0%,,aider --model openai/Qwen/Qwen2.5-Coder-32B-Instruct # via hyperbolic,71.6%,diff
gemma-3-27b-it,2025-03-10,4.9%,,aider --model openrouter/google/gemma-3-27b-it,100.0%,whole
gpt-4o-mini-2024-07-18,2024-07-18,3.6%,$0.32,aider --model gpt-4o-mini-2024-07-18,100.0%,whole
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-aime" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-aime"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">AIME 2025</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://www.vals.ai/benchmarks/aime-2025-05-30" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-30
                    </span>
                    <textarea class="hidden">
Lab,Model,Release Date,Score,Cost in/out,Latency
Humanity,Top 1% scorer (13/15),,86.7%,$604.60 / $604.60,12 minutes per question
OpenAI,o3 Mini Reasoning Model,2025-01-31,86.5%,$1.10 / $4.40,154.65 s
Google,Gemini 2.5 Pro Exp Reasoning Model,2025-03-25,85.8%,$1.25 / $10.00,143.91 s
OpenAI,o3 Reasoning Model,2025-04-16,85.3%,$2.00 / $8.00,266.18 s
xAI,Grok 3 Mini Fast High Reasoning Reasoning Model,2025-02-17,85.0%,$0.60 / $4.00,102.25 s
Alibaba,Qwen 3 (235B) Reasoning Model,2025-04-29,84.0%,$0.22 / $0.88,242.17 s
OpenAI,o4 Mini Reasoning Model,2025-04-16,83.7%,$1.10 / $4.40,55.11 s
Anthropic,Claude Sonnet 4 (Thinking) Reasoning Model,2025-05-22,76.3%,$3.00 / $15.00,271.79 s
DeepSeek,DeepSeek R1 Reasoning Model,2025-01-20,74.0%,$8.00 / $8.00,153.91 s
OpenAI,o1 Reasoning Model,2024-09-12,71.5%,$15.00 / $60.00,177.03 s
xAI,Grok 3 Mini Fast Low Reasoning Reasoning Model,2025-02-17,70.6%,$0.60 / $4.00,31.40 s
xAI,Grok 3 Beta,2025-02-17,58.7%,$3.00 / $15.00,63.99 s
DeepSeek,DeepSeek V3 (03/24/2025),2025-03-24,52.2%,$1.20 / $1.20,50.57 s
OpenAI,GPT 4.1 Mini,2025-04-14,49.4%,$0.40 / $1.60,33.14 s
Anthropic,Claude 3.7 Sonnet (Thinking) Reasoning Model,2025-02-24,44.6%,$3.00 / $15.00,303.71 s
Mistral,Mistral Medium 3.1 (05/2025),2025-05-07,42.3%,$0.40 / $2.00,65.95 s
Anthropic,Claude Opus 4 (Nonthinking),2025-05-22,41.3%,$15.00 / $75.00,37.03 s
OpenAI,GPT 4.1,2025-04-14,39.8%,$2.00 / $8.00,161.08 s
Anthropic,Claude Sonnet 4 (Nonthinking),2025-05-22,38.5%,$3.00 / $15.00,23.40 s
Google,Gemini 2.0 Flash (001),2024-12-11,29.8%,$0.10 / $0.40,11.21 s
DeepSeek,DeepSeek V3,2024-12-26,27.5%,$0.90 / $0.90,58.80 s
OpenAI,GPT 4.1 Nano,2025-04-14,27.3%,$0.10 / $0.40,11.91 s
Meta,Llama 4 Maverick,2025-04-05,25.2%,$0.27 / $0.85,15.50 s
Anthropic,Claude 3.7 Sonnet (Nonthinking),2025-02-24,22.3%,$3.00 / $15.00,18.93 s
Meta,Llama 4 Scout,2025-04-05,19.0%,$0.18 / $0.59,21.69 s
Google,Gemini 1.5 Pro (002),2024-09-24,18.7%,$1.25 / $5.00,10.64 s
Google,Gemini 1.5 Flash (002),2024-09-24,17.3%,$0.07 / $0.30,5.70 s
Meta,Llama 3.3 Instruct Turbo (70B),2024-12-06,16.0%,$0.88 / $0.88,11.24 s
xAI,Grok 2,2024-08-13,15.2%,$2.00 / $10.00,57.88 s
OpenAI,GPT 4o (2024-08-06),2024-08-06,14.0%,$2.50 / $10.00,68.37 s
Cohere,Command A,2025-03-13,13.3%,$2.50 / $10.00,23.35 s
OpenAI,GPT 4o (2024-11-20),2024-11-20,11.9%,$2.50 / $10.00,15.78 s
OpenAI,GPT 4o Mini,2024-07-18,11.5%,$0.15 / $0.60,28.77 s
Anthropic,Claude 3.5 Sonnet Latest,2024-06-20,10.0%,$3.00 / $15.00,9.19 s
Mistral,Mistral Large (11/2024),2024-11-19,9.2%,$2.00 / $6.00,19.68 s
Mistral,Mistral Small (02/2024),2024-02-26,5.6%,$0.20 / $0.60,13.23 s
Mistral,Mistral Small 3.1 (03/2025),2025-03-17,3.5%,$0.07 / $0.30,11.68 s
Anthropic,Claude 3.5 Haiku Latest,2024-10-22,3.3%,$1.00 / $5.00,9.05 s
AI21 Labs,Jamba 1.6 Large,2024-03-29,0.4%,$2.00 / $8.00,18.86 s
AI21 Labs,Jamba 1.6 Mini,2024-03-29,0.4%,$0.20 / $0.40,6.62 s
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-alansagi" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-alansagi"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Alan's AGI Countup</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://lifearchitect.ai/agi/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-04-30
                    </span>
                    <textarea class="hidden">
Date, Percentage
2025-04-05, 94
2025-03-13, 92
2025-02-20, 90
2024-12-16, 88
2024-12-06, 84
2024-10-22, 83
2024-09-15, 81
2024-07-15, 76
2024-06-15, 75
2024-05-15, 74
2024-05-14, 73
2024-03-15, 72
2024-03-14, 71
2024-02-15, 70
2024-02-14, 66
2024-01-15, 65
2023-12-15, 64
2023-12-14, 61
2023-10-15, 56
2023-09-15, 55
2023-07-15, 54
2023-07-14, 52
2023-07-13, 51
2023-06-15, 50
2023-05-15, 49
2023-03-15, 48
2023-03-14, 42
2023-02-15, 41
2022-05-15, 39
2021-06-15, 31
2020-11-15, 30
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-alansasi" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-alansasi"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Alan's ASI Countup</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://lifearchitect.ai/asi/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-15
                    </span>
                    <textarea class="hidden">
Date,Completion %,Running total,Increment,Items added
2022-07-08,2,1,1,#1
2024-10-30,4,2,1,#2
2025-01-16,6,3,1,#9
2025-03-12,8,4,1,#6
2025-03-31,12,6,2,#4 #5
2025-04-20,16,8,2,#28 #29
2025-05-19,20,10,2,#7 #8
2025-06-13,24,12,2,#13 #14
2025-06-15,26,13,1,#43
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-arb" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-arb"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Arbitrary Bench</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="#item-arb" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-15
                    </span>
                    <!-- I came up with this benchmark myself by picking an (almost) arbitrary set of benchmarks in 2023 and checking the top score on each one, every month since. -->
                    <textarea class="hidden">
Date,Average,GPQA,MMLU,MMLU-Pro,MATH,HumanEval,MMMU,MathVista,DocVQA
2023-11-15,70.8%,48.0%,86.5%,63.7%,72.6%,87.1%,63.1%,58.1%,87.2%
2024-02-15,72.9%,48.0%,86.5%,69.0%,72.6%,87.1%,63.1%,63.9%,93.1%
2024-03-15,73.2%,50.4%,86.5%,69.0%,72.6%,87.1%,63.1%,63.9%,93.1%
2024-04-15,74.7%,51.1%,88.6%,73.3%,73.8%,89.0%,64.5%,63.9%,93.1%
2024-05-15,76.1%,53.6%,88.7%,73.3%,76.6%,90.2%,69.1%,63.9%,93.1%
2024-07-15,78.1%,59.6%,88.7%,76.1%,76.6%,92.0%,69.1%,67.7%,95.2%
2024-08-15,78.3%,59.6%,88.7%,76.1%,76.6%,92.0%,69.1%,69.0%,95.2%
2024-09-15,81.5%,73.3%,90.8%,76.1%,86.5%,92.0%,69.1%,69.0%,95.2%
2024-10-15,82.1%,73.3%,90.8%,78.0%,90.0%,93.7%,70.4%,69.0%,95.2%
2024-12-15,84.9%,75.7%,91.8%,78.0%,96.4%,93.7%,77.3%,71.0%,95.2%
2025-01-15,85.6%,75.7%,91.8%,84.0%,96.4%,93.7%,77.3%,74.9%,95.2%
2025-02-15,87.6%,84.8%,91.8%,84.0%,97.9%,93.7%,78.2%,74.9%,95.2%
2025-03-15,88.0%,84.8%,91.8%,84.0%,97.9%,93.7%,81.7%,74.9%,95.2%
2025-04-15,89.7%,84.8%,91.8%,84.0%,97.9%,93.7%,82.9%,87.5%,95.2%
2025-05-15,89.7%,84.8%,91.8%,84.0%,97.9%,93.7%,82.9%,87.5%,95.2%
2025-06-15,90.0%,86.4%,91.8%,84.1%,97.9%,93.7%,82.9%,87.5%,95.3%
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-arcagi1" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-arcagi1"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">ARC-AGI 1</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://arcprize.org/leaderboard" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-22
                    </span>
                    <textarea class="hidden">
AI System,Release Date,Organization,System Type,ARC-AGI-1,ARC-AGI-2,Cost/Task
Human Panel,,Human,N/A,98.0%,100.0%,$17.00
Stem Grad,,Human,N/A,98.0%,N/A,$10.00
Avg. Mturker,,Human,N/A,77.0%,N/A,$3.00
o3-preview (Low)*,2025-04-16,OpenAI,CoT + Synthesis,75.7%,4.0%,$200.00
ARChitects,2024-12-05,ARC Prize 2024,Custom,56.0%,2.5%,$0.200
o3 (Medium),2025-04-16,OpenAI,CoT,53.0%,3.0%,$2.53
o4-mini (Medium),2025-04-16,OpenAI,CoT,41.8%,2.4%,$0.231
o3 (Low),2025-04-16,OpenAI,CoT,41.5%,2.0%,$1.22
Claude Sonnet 4 (Thinking 16K),2025-05-22,Anthropic,CoT,40.0%,5.9%,$0.486
Claude Opus 4 (Thinking 16K),2025-05-22,Anthropic,CoT,35.7%,8.6%,$1.93
o3-mini (High),2025-01-31,OpenAI,CoT,34.5%,3.0%,$0.547
Gemini 2.5 Flash (Preview) (Thinking 16K),2025-04-17,Google,CoT,33.3%,2.0%,$0.317
Gemini 2.5 Flash (Preview),2025-04-17,Google,CoT,33.3%,1.7%,$0.057
Gemini 2.5 Pro (Preview),2025-03-25,Google,CoT,33.0%,3.8%,$0.813
Gemini 2.5 Flash (Preview) (Thinking 24K),2025-04-17,Google,CoT,32.3%,2.5%,$0.319
"Gemini 2.5 Pro (Preview, Thinking 1K)",2025-03-25,Google,CoT,31.3%,3.4%,$0.804
Claude Opus 4 (Thinking 8K),2025-05-22,Anthropic,CoT,30.7%,4.5%,$1.16
o1 (Medium),2024-09-12,OpenAI,CoT,30.7%,1.3%,$2.61
Claude Sonnet 4 (Thinking 8K),2025-05-22,Anthropic,CoT,29.0%,2.1%,$0.265
Claude 3.7 (16K),2025-02-24,Anthropic,CoT,28.6%,0.7%,$0.510
Claude Sonnet 4 (Thinking 1K),2025-05-22,Anthropic,CoT,28.0%,0.9%,$0.142
Codex Mini (Latest),2025-05-16,OpenAI,CoT,27.3%,1.3%,$0.230
o1 (Low),2024-09-12,OpenAI,CoT,27.2%,0.8%,$1.47
Claude Opus 4 (Thinking 1K),2025-05-22,Anthropic,CoT,27.0%,0.0%,$0.750
Gemini 2.5 Flash (Preview) (Thinking 8K),2025-04-17,Google,CoT,25.8%,2.1%,$0.199
Claude Sonnet 4,2025-05-22,Anthropic,Base LLM,23.8%,1.3%,$0.127
o1-pro (Low),2024-09-12,OpenAI,CoT + Synthesis,23.3%,0.9%,$13.95
Claude Opus 4,2025-05-22,Anthropic,CoT,22.5%,1.3%,$0.639
o3-mini (Medium),2025-01-31,OpenAI,CoT,22.3%,2.1%,$0.284
o4-mini (Low),2025-04-16,OpenAI,CoT,21.3%,1.7%,$0.050
Deepseek R1 (05/28),2025-01-20,Deepseek,CoT,21.2%,1.1%,$0.053
Claude 3.7 (8K),2025-02-24,Anthropic,CoT,21.2%,0.9%,$0.360
o1-preview,2024-09-12,OpenAI,CoT,18.0%,N/A,$1.64
Icecuber,2024-06-09,ARC Prize 2024,Custom,17.0%,1.6%,$0.130
Grok 3 Mini (Low),2025-02-17,xAI,CoT,16.5%,0.4%,$0.013
Gemini 2.5 Flash (Preview) (Thinking 1K),2025-04-17,Google,CoT,16.0%,2.2%,$0.030
Deepseek R1,2025-01-20,Deepseek,CoT,15.8%,1.3%,$0.080
o3-mini (Low),2025-01-31,OpenAI,CoT,14.5%,0.0%,$0.062
o1-mini,2024-09-12,OpenAI,CoT,14.0%,0.8%,$0.191
Claude 3.7,2025-02-24,Anthropic,Base LLM,13.6%,0.0%,$0.120
Claude 3.7 (1K),2025-02-24,Anthropic,CoT,11.6%,0.4%,$0.140
GPT-4.5,2025-02-27,OpenAI,Base LLM,10.3%,0.8%,$2.10
GPT-4.1,2025-04-14,OpenAI,Base LLM,5.5%,0.4%,$0.069
Grok 3,2025-02-17,xAI,Base LLM,5.5%,0.0%,$0.142
GPT-4o,2024-05-13,OpenAI,Base LLM,4.5%,0.0%,$0.080
Llama 4 Maverick,2025-04-05,Meta,Base LLM,4.4%,0.0%,$0.012
GPT-4.1-Mini,2025-04-14,OpenAI,Base LLM,3.5%,0.0%,$0.014
Llama 4 Scout,2025-04-05,Meta,Base LLM,0.5%,0.0%,$0.006
GPT-4.1-Nano,2025-04-14,OpenAI,Base LLM,0.0%,0.0%,$0.004
Gemini 2.0 Flash,2024-12-11,Google,Base LLM,N/A,1.3%,$0.004
Gemini 1.5 Pro,2024-02-15,Google,Base LLM,N/A,0.8%,$0.040
GPT-4o-mini,2024-07-18,OpenAI,Base LLM,N/A,0.0%,$0.010
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-arcagi2" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-arcagi2"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">ARC-AGI 2</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://arcprize.org/leaderboard" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-22
                    </span>
                    <textarea class="hidden">
AI System,Release Date,Organization,System Type,ARC-AGI-2,Cost/Task
Human Panel,,Human,N/A,100.0%,$17.00
Claude Opus 4 (Thinking 16K),2025-05-22,Anthropic,CoT,8.6%,$1.93
Claude Sonnet 4 (Thinking 16K),2025-05-22,Anthropic,CoT,5.9%,$0.486
Claude Opus 4 (Thinking 8K),2025-05-22,Anthropic,CoT,4.5%,$1.16
o3-preview (Low)*,2025-04-16,OpenAI,CoT + Synthesis,4.0%,$200.00
Gemini 2.5 Pro (Preview),2025-03-25,Google,CoT,3.8%,$0.813
"Gemini 2.5 Pro (Preview, Thinking 1K)",2025-03-25,Google,CoT,3.4%,$0.804
o3-mini (High),2025-01-31,OpenAI,CoT,3.0%,$0.547
o3 (Medium),2025-04-16,OpenAI,CoT,3.0%,$2.53
Gemini 2.5 Flash (Preview) (Thinking 24K),2025-04-17,Google,CoT,2.5%,$0.319
ARChitects,2024-12-05,ARC Prize 2024,Custom,2.5%,$0.200
o4-mini (Medium),2025-04-16,OpenAI,CoT,2.4%,$0.231
Gemini 2.5 Flash (Preview) (Thinking 1K),2025-04-17,Google,CoT,2.2%,$0.030
Gemini 2.5 Flash (Preview) (Thinking 8K),2025-04-17,Google,CoT,2.1%,$0.199
Claude Sonnet 4 (Thinking 8K),2025-05-22,Anthropic,CoT,2.1%,$0.265
o3-mini (Medium),2025-01-31,OpenAI,CoT,2.1%,$0.284
Gemini 2.5 Flash (Preview) (Thinking 16K),2025-04-17,Google,CoT,2.0%,$0.317
o3 (Low),2025-04-16,OpenAI,CoT,2.0%,$1.22
Gemini 2.5 Flash (Preview),2025-04-17,Google,CoT,1.7%,$0.057
o4-mini (Low),2025-04-16,OpenAI,CoT,1.7%,$0.050
Icecuber,2024-06-09,ARC Prize 2024,Custom,1.6%,$0.130
Gemini 2.0 Flash,2024-12-11,Google,Base LLM,1.3%,$0.004
Deepseek R1,2025-01-20,Deepseek,CoT,1.3%,$0.080
Codex Mini (Latest),2025-05-16,OpenAI,CoT,1.3%,$0.230
Claude Sonnet 4,2025-05-22,Anthropic,Base LLM,1.3%,$0.127
Claude Opus 4,2025-05-22,Anthropic,CoT,1.3%,$0.639
o1 (Medium),2024-09-12,OpenAI,CoT,1.3%,$2.61
Deepseek R1 (05/28),2025-01-20,Deepseek,CoT,1.1%,$0.053
o1-pro (Low),2024-09-12,OpenAI,CoT + Synthesis,0.9%,$13.95
Claude 3.7 (8K),2025-02-24,Anthropic,CoT,0.9%,$0.360
Claude Sonnet 4 (Thinking 1K),2025-05-22,Anthropic,CoT,0.9%,$0.142
o1-mini,2024-09-12,OpenAI,CoT,0.8%,$0.191
o1 (Low),2024-09-12,OpenAI,CoT,0.8%,$1.47
Gemini 1.5 Pro,2024-02-15,Google,Base LLM,0.8%,$0.040
GPT-4.5,2025-02-27,OpenAI,Base LLM,0.8%,$2.10
Claude 3.7 (16K),2025-02-24,Anthropic,CoT,0.7%,$0.510
GPT-4.1,2025-04-14,OpenAI,Base LLM,0.4%,$0.069
Grok 3 Mini (Low),2025-02-17,xAI,CoT,0.4%,$0.013
Claude 3.7 (1K),2025-02-24,Anthropic,CoT,0.4%,$0.140
Claude 3.7,2025-02-24,Anthropic,Base LLM,0.0%,$0.120
GPT-4o,2024-05-13,OpenAI,Base LLM,0.0%,$0.080
GPT-4o-mini,2024-07-18,OpenAI,Base LLM,0.0%,$0.010
Avg. Mturker,,Human,N/A,N/A,$3.00
Stem Grad,,Human,N/A,N/A,$10.00
Llama 4 Maverick,2025-04-05,Meta,Base LLM,0.0%,$0.012
Llama 4 Scout,2025-04-05,Meta,Base LLM,0.0%,$0.006
GPT-4.1-Nano,2025-04-14,OpenAI,Base LLM,0.0%,$0.004
GPT-4.1-Mini,2025-04-14,OpenAI,Base LLM,0.0%,$0.014
o3-mini (Low),2025-01-31,OpenAI,CoT,0.0%,$0.062
o1-preview,2024-09-12,OpenAI,CoT,N/A,$1.64
Claude Opus 4 (Thinking 1K),2025-05-22,Anthropic,CoT,0.0%,$0.750
Grok 3,2025-02-17,xAI,Base LLM,0.0%,$0.142
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-aaii" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-aaii"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Artificial Analysis (AAII)</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://artificialanalysis.ai/leaderboards/models" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-10
                    </span>
                    <textarea class="hidden">
Model,Release Date,Context window,Intelligence score,Price,Output tokens/s,Latency
o3-pro,2025-06-10,200k,71,$35.00,23.3,106.91
Gemini 2.5 Pro,2025-03-25,1m,70,$3.44,147.9,34.67
o3,2025-04-16,128k,70,$3.50,140.1,16.93
o4-mini (high),2025-04-16,200k,70,$1.93,161.6,36.39
Gemini 2.5 Pro (Mar '25),2025-03-25,1m,69,$3.44,159.6,35.93
DeepSeek R1 0528 (May '25),2025-05-28,128k,68,$0.96,29.4,2.37
Gemini 2.5 Pro (May' 25),2025-03-25,1m,68,$3.44,157.0,31.50
Grok 3 mini Reasoning (high),2025-02-17,1m,67,$0.35,209.9,0.41
o3-mini (high),2025-01-31,200k,66,$1.93,109.6,62.93
Gemini 2.5 Flash (Reasoning),2025-04-17,1m,65,$0.99,350.8,7.32
Claude 4 Opus Thinking,2025-05-22,200k,64,$30.00,65.4,2.10
MiniMax M1 80k,,1m,63,$0.82,,
o3-mini,2025-01-31,200k,63,$1.93,108.5,17.05
Qwen3 235B (Reasoning),2025-04-29,128k,62,$2.63,70.9,1.18
o1,2024-09-12,200k,62,$26.25,206.1,12.91
MiniMax M1 40k,,1m,61,$0.82,23.2,0.97
Llama Nemotron Ultra Reasoning,2025-04-07,128k,61,$0.90,42.9,0.66
Claude 4 Sonnet Thinking,2025-05-22,200k,61,$6.00,51.2,1.27
Gemini 2.5 Flash (April '25) (Reasoning),2025-04-17,1m,60,$0.99,398.6,6.33
DeepSeek R1 (Jan '25),2025-01-20,128k,60,$2.36,,
o1-preview,2024-09-12,128k,60,$26.25,164.9,20.01
Qwen3 32B (Reasoning),2025-04-29,128k,59,$2.63,60.4,1.09
QwQ-32B,,131k,58,$0.47,99.0,0.40
Claude 4 Opus,2025-05-22,200k,58,$30.00,60.7,2.29
Claude 3.7 Sonnet Thinking,2025-02-24,200k,57,$6.00,89.1,1.07
o1-pro,2024-09-12,200k,56,$262.50,,
Grok 3 Reasoning Beta,2025-02-17,1m,56,$0.00,,
Magistral Medium,,128k,56,$2.75,137.0,0.39
Qwen3 14B (Reasoning),2025-04-29,128k,56,$1.31,65.4,1.02
Qwen3 30B A3B (Reasoning),2025-04-29,128k,56,$0.75,92.2,1.11
Gemini 2.5 Flash-Lite (Reasoning),2025-04-17,1m,55,$0.17,872.6,4.59
Magistral Small,,128k,55,$0.75,199.7,0.32
o1-mini,2024-09-12,128k,54,$1.93,257.6,8.88
Gemini 2.5 Flash,2025-04-17,1m,53,$0.26,281.7,0.35
DeepSeek V3 0324 (Mar '25),2024-12-26,128k,53,$0.48,31.7,2.38
Claude 4 Sonnet,2025-05-22,200k,53,$6.00,48.5,1.35
GPT-4.5 (Preview),2025-02-27,128k,53,$93.75,78.6,0.98
GPT-4.1 mini,2025-04-14,1m,53,$0.70,75.8,0.41
GPT-4.1,2025-04-14,1m,53,$3.50,163.5,0.42
Gemini 2.0 Flash Thinking exp. (Jan '25),2024-12-11,1m,52,$0.00,,
DeepSeek R1 0528 Qwen3 8B,2025-05-28,128k,52,$0.07,89.8,0.68
DeepSeek R1 Distill Qwen 32B,2025-05-28,128k,52,$0.30,21.6,1.21
Qwen3 8B (Reasoning),2025-04-29,128k,51,$0.66,99.0,0.97
Llama 3.3 Nemotron Super 49B Reasoning,2024-12-06,128k,51,$0.00,,
Grok 3,2025-02-17,1m,51,$6.00,94.8,0.42
Llama 4 Maverick,2025-04-05,1m,51,$0.39,170.6,0.33
GPT-4o (March 2025),2025-03-26,128k,50,$7.50,204.7,0.45
Gemini 2.0 Pro Experimental,2025-02-05,2m,49,$0.00,54.0,16.77
DeepSeek R1 Distill Qwen 14B,2025-01-20,128k,49,$0.20,83.1,0.66
Mistral Medium 3,2025-05-07,128k,49,$0.80,79.4,0.39
Sonar Reasoning,,127k,49,$2.00,88.4,0.63
Gemini 2.5 Flash,2025-04-17,1m,49,$0.26,322.7,0.43
DeepSeek R1 Distill Llama 70B,2025-01-20,128k,48,$0.80,65.3,0.49
Claude 3.7 Sonnet,2025-02-24,200k,48,$6.00,78.4,1.18
Gemini 2.0 Flash,2024-12-11,1m,48,$0.17,251.2,0.37
Qwen3 4B (Reasoning),2025-04-29,32k,47,$0.40,104.7,1.00
Reka Flash 3,,128k,47,$0.35,56.1,0.97
Qwen3 235B,2025-04-29,128k,47,$1.23,71.9,1.21
Gemini 2.0 Flash (exp),2024-12-11,1m,46,$0.00,233.0,0.25
Gemini 2.5 Flash-Lite,2025-04-17,1m,46,$0.17,649.1,0.20
DeepSeek V3 (Dec '24),2024-12-26,128k,46,$0.48,,
Qwen2.5 Max,2025-01-29,32k,45,$2.80,39.7,1.30
Llama 3.1 Nemotron Nano 4B v1.1 (Reasoning),2025-05-03,128k,45,$0.00,,
Gemini 1.5 Pro (Sep),2024-09-24,2m,45,$2.19,97.4,0.43
Claude 3.5 Sonnet (Oct),2024-10-22,200k,44,$6.00,77.3,2.68
Qwen3 32B,2025-04-29,128k,44,$1.23,60.3,1.07
Sonar,,127k,43,$1.00,94.8,0.94
Llama 4 Scout,2025-04-05,10m,43,$0.26,132.9,0.36
Sonar Pro,,200k,43,$6.00,154.7,0.86
QwQ 32B-Preview,,33k,43,$0.67,59.9,0.56
Nova Premier,2024-12-03,1m,43,$5.00,85.6,0.88
Qwen3 30B A3B,2025-04-29,128k,43,$0.35,92.7,1.03
GPT-4o (Nov '24),2024-11-29,128k,41,$4.38,189.2,0.41
Gemini 2.0 Flash-Lite (Feb '25),2025-02-05,1m,41,$0.13,228.6,0.34
Llama 3.3 70B,2024-12-06,128k,41,$0.59,122.1,0.43
GPT-4.1 nano,2025-04-14,1m,41,$0.17,235.5,0.31
Qwen3 14B,2025-04-29,128k,41,$0.61,66.3,1.02
GPT-4o (May '24),2024-05-13,128k,41,$7.50,109.7,0.49
Gemini 2.0 Flash-Lite (Preview),2025-02-05,1m,41,$0.13,226.4,0.33
GPT-4o (Aug '24),2024-05-13,128k,41,$4.38,112.3,0.55
Llama 3.1 405B,2024-07-23,128k,40,$3.50,33.5,0.62
Qwen2.5 72B,,131k,40,$0.00,58.3,1.12
MiniMax-Text-01,,4m,40,$0.42,28.8,0.96
Phi-4,,16k,40,$0.22,31.0,0.48
Claude 3.5 Sonnet (June),2024-06-20,200k,40,$6.00,78.7,1.07
Command A,2025-03-13,256k,40,$4.38,181.1,0.67
Tulu3 405B,,128k,40,$0.00,,
GPT-4o (ChatGPT),2024-05-13,128k,40,$7.50,,
Llama 3.3 Nemotron Super 49B v1,2024-12-06,128k,39,$0.00,,
Grok 2,2024-08-13,131k,39,$0.00,,
Gemini 1.5 Flash (Sep),2024-09-24,1m,39,$0.13,192.0,0.21
GPT-4 Turbo,2024-04-09,128k,39,$15.00,51.1,1.02
Mistral Large 2 (Nov '24),2024-11-19,128k,38,$3.00,84.1,0.44
Qwen3 1.7B (Reasoning),2025-04-29,32k,38,$0.40,138.0,1.03
Gemma 3 27B,2025-03-10,128k,38,$0.00,47.2,0.61
Grok Beta,,128k,38,$7.50,67.5,0.33
Pixtral Large,,128k,37,$3.00,61.1,0.47
Qwen2.5 Instruct 32B,,128k,37,$0.15,,
Llama 3.1 Nemotron 70B,2024-07-23,128k,37,$0.17,45.1,0.29
Nova Pro,2024-12-03,300k,37,$1.40,,
Qwen3 8B,2025-04-29,128k,37,$0.31,100.2,1.07
Mistral Large 2 (Jul '24),2024-07-24,128k,37,$3.00,102.1,0.42
Qwen2.5 Coder 32B,,131k,36,$0.15,53.5,0.30
GPT-4,2023-03-14,8k,36,$37.50,35.4,0.70
GPT-4o mini,2024-07-18,128k,36,$0.26,88.0,0.43
Llama 3.1 70B,2024-07-23,128k,35,$0.76,64.1,0.37
Mistral Small 3.1,2025-03-17,128k,35,$0.15,158.4,0.29
Mistral Small 3,2024-02-26,32k,35,$0.15,147.1,0.32
DeepSeek-V2.5 (Dec '24),2024-09-05,128k,35,$0.17,,
Qwen3 4B,2025-04-29,32k,35,$0.19,106.5,1.05
Claude 3 Opus,2024-03-04,200k,35,$30.00,27.9,1.14
Claude 3.5 Haiku,2024-10-22,200k,35,$1.60,64.6,1.16
Gemini 2.0 Flash Thinking exp. (Dec '24),2024-12-11,2m,35,$0.00,,
DeepSeek-V2.5,2024-09-05,128k,35,$0.17,,
Devstral,,256k,34,$0.15,139.5,0.33
Mistral Saba,2023-09-27,32k,34,$0.30,95.8,0.31
DeepSeek R1 Distill Llama 8B,2025-01-20,128k,34,$0.04,56.3,0.84
Reka Core,,128k,34,$2.00,27.3,1.20
Gemma 3 12B,2025-03-10,128k,34,$0.06,,
Gemini 1.5 Pro (May),2024-02-15,2m,34,$2.19,,
R1 1776,,128k,34,$3.50,,
Qwen2.5 Turbo,,1m,34,$0.09,109.2,1.05
Reka Flash,,128k,34,$0.35,45.9,1.17
Gemma 3 1B,2025-03-10,32k,33,$0.00,,
Llama 3.2 90B (Vision),2024-09-25,128k,33,$0.72,40.5,0.26
Solar Mini,,4k,33,$0.15,94.3,1.08
Reka Flash (Feb '24),,128k,33,$0.35,45.6,1.20
Reka Edge,,128k,33,$0.10,85.9,1.15
Qwen2 72B,2024-07-23,131k,33,$0.00,30.9,1.31
Nova Lite,2024-12-03,300k,33,$0.10,263.8,0.34
Gemini 1.5 Flash-8B,2024-02-15,1m,31,$0.07,253.5,0.20
DeepHermes 3 - Mistral 24B,2023-09-27,32k,30,$0.00,,
Jamba 1.5 Large,2024-03-29,256k,29,$3.50,,
Hermes 3 - Llama-3.1 70B,2024-04-18,128k,29,$0.00,,
DeepSeek-Coder-V2,2024-05-06,128k,29,$0.17,,
Jamba 1.6 Large,2024-03-29,256k,29,$3.50,61.2,0.79
Gemini 1.5 Flash (May),2024-02-15,1m,28,$0.13,,
Nova Micro,2024-12-03,130k,28,$0.06,372.2,0.33
Yi-Large,,32k,28,$3.00,67.8,0.36
Claude 3 Sonnet,2024-03-04,200k,28,$6.00,61.2,0.69
Codestral (Jan '25),,256k,28,$0.45,179.3,0.30
Llama 3 70B,2024-04-18,8k,27,$0.84,47.6,0.41
Mistral Small (Sep '24),2024-02-26,33k,27,$0.30,114.5,0.32
Gemini 1.0 Ultra,2024-02-08,33k,27,$0.00,,
Gemma 3n E4B,2024-02-21,32k,27,$0.00,,
Phi-4 Multimodal,,128k,27,$0.00,20.7,0.33
Qwen2.5 Coder 7B,2023-09-13,131k,27,$0.00,,
Mistral Large (Feb '24),2023-09-27,33k,26,$6.00,103.4,0.41
Jamba Instruct,2024-03-29,256k,26,$0.00,,
Mixtral 8x22B,2024-04-10,65k,26,$3.00,53.7,0.37
Phi-4 Mini,,128k,26,$0.00,30.0,0.39
Gemma 2 27B,2024-06-27,8k,26,$0.80,,
Llama 3.2 11B (Vision),2024-09-25,128k,25,$0.16,113.8,0.30
Qwen3 1.7B,2025-04-29,32k,25,$0.19,140.7,0.93
Qwen1.5 Chat 110B,,32k,25,$0.00,23.7,1.55
Phi-3 Medium 14B,2024-04-23,128k,25,$0.30,52.9,0.43
Gemma 3 4B,2025-03-10,128k,24,$0.03,,
Claude 2.1,,200k,24,$12.00,13.7,0.98
Claude 3 Haiku,2024-03-13,200k,24,$0.50,127.3,0.55
Llama 3.1 8B,2024-07-23,128k,24,$0.10,227.0,0.28
Pixtral 12B,,128k,23,$0.15,38.7,0.37
Qwen3 0.6B (Reasoning),2025-04-29,32k,23,$0.40,228.6,0.90
Claude 2.0,,100k,23,$12.00,30.9,0.96
DeepSeek-V2,2024-05-06,128k,23,$0.17,,
Mistral Small (Feb '24),2024-02-26,33k,23,$1.50,161.8,0.29
Mistral Medium,2023-09-27,33k,23,$4.09,74.6,0.43
GPT-3.5 Turbo,2024-01-25,4k,23,$0.75,92.6,0.35
Ministral 8B,,128k,22,$0.10,204.8,0.30
Gemma 2 9B,2024-06-27,8k,22,$0.12,,
Phi-3 Mini,2024-04-23,4k,22,$0.00,,
Arctic,,4k,22,$0.00,,
Qwen Chat 72B,,34k,22,$1.00,,
LFM 40B,,32k,22,$0.15,161.3,0.16
Command-R+,2024-08-30,128k,21,$4.38,52.7,1.76
Llama 3 8B,2024-04-18,8k,21,$0.09,103.7,0.33
PALM-2,2023-05-10,8k,21,$0.00,,
Gemini 1.0 Pro,,33k,21,$0.75,,
DeepSeek Coder V2 Lite,2024-05-06,128k,20,$0.00,,
Codestral (May '24),,33k,20,$0.30,185.3,0.29
Aya Expanse 32B,,128k,20,$0.75,126.9,0.80
Llama 2 Chat 70B,2023-07-01,4k,20,$0.00,,
DeepSeek LLM 67B (V1),,4k,20,$0.00,,
Llama 2 Chat 13B,2023-07-01,4k,20,$0.00,,
Command-R+ (Apr '24),2024-08-30,128k,20,$6.00,58.5,1.47
OpenChat 3.5,,8k,20,$0.05,56.1,0.24
DBRX,2024-03-27,33k,20,$0.00,,
Ministral 3B,,128k,20,$0.04,263.6,0.28
Mistral NeMo,2023-09-27,128k,20,$0.15,168.0,0.29
Llama 3.2 3B,2024-09-25,128k,20,$0.05,113.0,0.38
DeepSeek R1 Distill Qwen 1.5B,2025-01-20,128k,19,$0.18,383.9,0.19
Jamba 1.5 Mini,2024-03-29,256k,18,$0.25,,
Jamba 1.6 Mini,2024-03-29,256k,18,$0.25,197.5,0.57
Mixtral 8x7B,2023-12-09,33k,17,$0.70,100.0,0.34
Qwen3 0.6B,2025-04-29,32k,17,$0.19,232.5,0.89
DeepHermes 3 - Llama-3.1 8B,2024-04-18,128k,16,$0.00,,
Aya Expanse 8B,,8k,16,$0.75,185.4,0.58
Command-R,2024-03-11,128k,15,$0.26,81.3,1.15
Command-R (Mar '24),2024-03-11,128k,15,$0.75,175.2,0.60
Qwen Chat 14B,,8k,14,$0.00,,
Claude Instant,,100k,14,$1.20,64.3,0.54
Codestral-Mamba,,256k,14,$0.25,,
Llama 65B,2023-02-24,2k,11,$0.00,,
Mistral 7B,2023-09-27,8k,10,$0.25,119.3,0.31
Llama 3.2 1B,2024-09-25,128k,10,$0.05,182.7,0.27
Llama 2 Chat 7B,2023-07-01,4k,8,$0.10,131.3,0.47
GPT-4o Realtime (Dec '24),2024-05-13,128k,,$0.00,,
GPT-4o mini Realtime (Dec '24),2024-07-18,128k,,$0.00,,
Sonar Reasoning Pro,,127k,,$0.00,,
Grok 3 mini Reasoning (low),2025-02-17,1m,,$0.35,209.4,0.31
GPT-3.5 Turbo (0613),2024-01-25,4k,,$0.00,,
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-confab" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-confab"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Confabulations</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://github.com/lechmazur/confabulations/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-10
                    </span>
                    <textarea class="hidden">
Model,Release Date,Perfection %,Confab %,Non-Resp %,Weighted %
Gemini 2.5 Pro Preview 05-06,2025-05-06,89.38,5.9,15.3,10.62
Grok 3 Mini Beta (high),2025-02-17,89.2,6.9,14.7,10.8
Gemini 2.5 Pro Exp 03-25,2025-03-25,89.2,4,17.6,10.8
o1 (medium reasoning),2024-09-12,88.26,10.9,12.6,11.74
Qwen 3 30B A3B,2025-04-29,87.72,12.9,11.7,12.28
Gemini 2.5 Pro Preview 06-05,2025-06-05,87.62,4,20.8,12.38
Gemini 2.0 Flash Think Exp 01-21,2024-12-11,87.57,14.9,10,12.43
DeepSeek R1,2025-01-20,87.35,17.3,8,12.65
o1-preview,2024-09-12,86.96,18.3,7.8,13.04
Claude Sonnet 4 Thinking 16K,2025-05-22,86.8,2.5,23.9,13.2
Gemini 1.5 Pro (Sept),2024-09-24,86.46,16.8,10.2,13.54
GPT-4.5 Preview,2025-02-27,86.36,11.9,15.4,13.64
Grok 3 Mini Beta (low),2025-02-17,85.96,10.9,17.2,14.04
Grok 3 Beta (no reasoning),2025-02-17,85.81,17.8,10.6,14.19
o3-pro (medium reasoning),2025-06-10,85.78,23.4,5.1,14.22
o3 (high reasoning),2025-04-16,85.62,24.8,4,14.38
DeepSeek R1 05/28,2025-01-20,85.44,12.9,16.2,14.56
Claude 3.7 Sonnet Thinking 16K,2025-02-24,85.29,7.9,21.5,14.71
Claude Sonnet 4 (no reasoning),2025-05-22,85.15,5.4,24.2,14.85
GPT-4o 2024-08-06,2024-08-06,84.66,22.3,8.4,15.34
Qwen QwQ-32B 16K,2025-03-05,84.43,25.2,5.9,15.57
Qwen 3 235B A22B,2025-04-29,84.39,23.3,8,15.61
o4-mini (high reasoning),2025-04-16,84.21,26.7,4.8,15.79
Claude Opus 4 Thinking 16K,2025-05-22,84.08,2.5,29.4,15.92
GPT-4o Feb 2025,2025-02-18,83.37,26.7,6.5,16.63
Gemini 2.5 Flash Preview 24K,2025-04-17,83.19,4.5,29.2,16.81
Claude Opus 4 (no reasoning),2025-05-22,82.94,3,31.2,17.06
GPT-4o 2024-11-20,2024-11-20,82.79,26.2,8.2,17.21
Llama 3.1 405B,2024-07-23,82.38,14.4,20.9,17.62
o3-mini (medium reasoning),2025-01-31,82.09,27.2,8.6,17.91
Gemini 2.0 Pro Exp 02-05,2025-02-05,81.57,15.8,21,18.43
o3-mini (high reasoning),2025-01-31,81.57,30.7,6.2,18.43
o1-mini,2024-09-12,81.45,26.2,10.9,18.55
Qwen 2.5 72B,2024-09-19,80.91,32.2,6,19.09
Claude 3.7 Sonnet,2025-02-24,80.24,25.2,14.3,19.76
Claude 3.5 Sonnet 2024-10-22,2024-10-22,80.06,12.9,27,19.94
Grok 2 12-12,2024-08-13,79.86,25.7,14.5,20.14
GPT-4o Mar 2025,2025-03-26,79.19,38.1,3.5,20.81
Mistral Large 2,2024-11-19,78.6,32.2,10.6,21.4
Qwen 2.5 Max,2025-01-29,78.22,31.2,12.4,21.78
Mistral Medium 3,2025-05-07,78.1,38.1,5.7,21.9
Llama 4 Maverick,2025-04-05,77.42,28.2,16.9,22.58
Claude 3 Opus,2024-03-04,77.3,28.2,17.2,22.7
Llama 3.3 70B,2024-12-06,77.19,17.8,27.8,22.81
MiniMax-Text-01,2025-01-12,76.08,44.6,3.3,23.92
Mistral Small 3,2025-01-30,74.79,38.6,11.8,25.21
DeepSeek V3-0324,2024-12-26,73.85,39.1,13.2,26.15
Gemini 2.0 Flash,2024-12-11,73.15,24.3,29.4,26.85
Gemma 2 27B,2024-06-27,72.76,47.3,7.2,27.24
GPT-4 Turbo,2024-04-09,71.58,26.7,30.1,28.42
Microsoft Phi-4,2024-12-12,70.57,52.5,6.4,29.43
Amazon Nova Pro,2024-12-03,69.95,54.5,5.6,30.05
Claude 3 Haiku,2024-03-13,65.79,56.9,11.5,34.21
Claude 3.5 Haiku,2024-10-22,63.26,65.8,7.6,36.74
GPT-4o mini,2024-07-18,62.79,60.9,13.5,37.21
Gemma 3 27B,2025-03-10,59.74,66.3,14.2,40.26
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-facts" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-facts"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">FACTS Grounding</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://www.kaggle.com/benchmarks/google/facts-grounding" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-05
                    </span>
                    <textarea class="hidden">
Model,Release Date,Score,95% CI,Organization,License,Knowledge Cutoff
gemini-2.5-pro-preview-05-06,2025-06-05,86.2%,±1.6%,Google,Proprietary,01/2025
gemini-2.5-flash-preview-05-20,2024-12-11,85.8%,±1.7%,Google,Proprietary,01/2025
gemini-2.0-flash-001,2024-12-11,85.6%,±1.7%,Google,Proprietary,06/2024
claude-3-5-sonnet-20241022,2024-06-20,83.3%,±1.8%,Anthropic,Proprietary,04/2024
deepseek-r1,2025-01-20,82.4%,±1.8%,DeepSeek,DeepSeek License Agreement,06/2024
gemini-1.5-flash-002,2024-09-24,82.4%,±1.8%,Google,Proprietary,11/2023
gemini-1.5-pro-002,2024-09-24,81.2%,±1.8%,Google,Proprietary,11/2023
gemma-3-27b-it,2025-03-10,80.6%,±1.9%,Google,Gemma,Undisclosed
gemma-3-12b-it,2025-03-10,80.5%,±1.9%,Google,Gemma,Undisclosed
gemini-1.5-flash-8b,2024-02-15,79.7%,±1.9%,Google,Proprietary,08/2024
claude-sonnet-4-20250514,2025-05-22,79.1%,±1.9%,Anthropic,Proprietary,03/2025
claude-3-7-sonnet-20250219,2025-02-24,78.8%,±1.9%,Anthropic,Proprietary,11/2024
o1-2024-12-17,2024-09-12,78.8%,±1.9%,OpenAI,Proprietary,09/2023
claude-3-5-haiku-20241022,2024-10-22,78.1%,±2.0%,Anthropic,Proprietary,04/2024
claude-opus-4-20250514,2025-05-22,77.7%,±2.0%,Anthropic,Proprietary,03/2025
o3-mini-2025-01-31,2025-01-31,77.6%,±2.0%,OpenAI,Proprietary,09/2023
grok-2-1212,2024-08-13,76.2%,±2.0%,xAI,Proprietary,07/2024
gpt-4o-2024-08-06,2024-05-13,75.9%,±2.0%,OpenAI,Proprietary,10/2023
grok-3,2025-02-17,75.7%,±2.0%,xAI,Proprietary,11/2024
grok-3-mini,2025-02-17,75.0%,±2.0%,xAI,Proprietary,11/2024
gpt-4.1-2025-04-14,2025-04-14,74.5%,±2.1%,OpenAI,Proprietary,05/2024
mistral-large-2411,2024-11-19,72.6%,±2.1%,Mistral AI,Mistral AI Research License,10/2024
open-mixtral-8x22b-2404,2024-04-10,70.1%,±2.2%,Mistral AI,Apache 2.0,Undisclosed
o3-2025-04-16,2025-04-16,69.6%,±2.2%,OpenAI,Proprietary,05/2024
gpt-4o-mini-2024-07-18,2024-07-18,68.4%,±2.2%,OpenAI,Proprietary,09/2023
gemma-3-4b-it,2025-03-10,64.8%,±2.3%,Google,Gemma,Undisclosed
deepseek-v3,2024-12-26,63.9%,±2.3%,DeepSeek,DeepSeek License Agreement,06/2024
o1-mini-2024-09-12,2024-09-12,62.1%,±2.3%,OpenAI,Proprietary,09/2023
o4-mini-2025-04-16,2025-04-16,62.1%,±2.3%,OpenAI,Proprietary,05/2024
codestral-2501,2025-01-13,59.7%,±2.3%,Mistral AI,Mistral AI Research License,Undisclosed
ministral-8b-2410,2024-10-16,56.1%,±2.3%,Mistral AI,Mistral AI Research License,09/2024
ministral-3b-2410,2024-10-16,52.2%,±2.4%,Mistral AI,Mistral AI Research License,09/2024
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-frontier" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-frontier"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">FrontierMath</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://epoch.ai/data/ai-benchmarking-dashboard?view=table" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-10
                    </span>
                    <textarea class="hidden">
Model,Release Date,Score
gemini-2.5-pro-preview-06-05,2025-06-05,60.0
o3-mini-2025-01-31_high,2025-01-31,40.0
o4-mini-2025-04-16_high,2025-04-16,30.0
o4-mini-2025-04-16_low,2025-04-16,30.0
o4-mini-2025-04-16_medium,2025-04-16,20.0
o4-mini-2025-04-16_medium,2025-04-16,19.3
o4-mini-2025-04-16_high,2025-04-16,17.2
o3-mini-2025-01-31_medium,2025-01-31,11.3
o3-mini-2025-01-31_high,2025-01-31,11.0
o3-2025-04-16_high,2025-04-16,10.3
o3-2025-04-16_low,2025-04-16,10.3
gpt-4.1-mini-2025-04-14,2025-04-14,10.0
o3-2025-04-16_high,2025-04-16,10.0
o3-2025-04-16_low,2025-04-16,10.0
o3-2025-04-16_medium,2025-04-16,10.0
o4-mini-2025-04-16_low,2025-04-16,09.7
o1-2024-12-17_high,2024-12-17,09.3
o3-mini-2025-01-31_medium,2025-01-31,08.1
grok-3-mini-beta_high,2025-02-17,05.9
gpt-4.1-2025-04-14,2025-04-14,05.5
gpt-4.1-mini-2025-04-14,2025-04-14,04.5
claude-3-7-sonnet-20250219_16K,2025-02-24,04.1
grok-3-beta,2025-02-17,03.8
claude-3-7-sonnet-20250219_32K,2025-02-24,03.4
claude-3-7-sonnet-20250219,2025-02-24,03.1
claude-3-7-sonnet-20250219_64K,2025-02-24,03.1
grok-3-mini-beta_low,2025-02-17,02.8
claude-3-5-sonnet-20241022,2024-10-22,02.1
o1-mini-2024-09-12_medium,2024-09-12,01.7
DeepSeek-V3,2024-12-26,01.7
gemini-2.0-flash-001,2024-12-11,01.7
qwen-plus-2025-04-28,2025-04-28,01.7
o1-mini-2024-09-12_high,2024-09-12,01.4
claude-3-5-sonnet-20240620,2024-06-20,01.0
qwen-max-2025-01-25,2025-01-29,01.0
gpt-4.1-nano-2025-04-14,2025-04-14,01.0
grok-2-1212,2024-08-13,00.7
Llama-4-Maverick-17B-128E-Instruct-FP8,2025-04-05,00.7
gpt-4o-2024-11-20,2024-11-20,00.3
mistral-large-2411,2024-11-19,00.3
claude-3-5-haiku-20241022,2024-10-22,00.3
gpt-4o-2024-08-06,2024-08-06,00.3
mistral-medium-2505,2025-05-07,00.3
grok-2-1212,2024-08-13,00.0
claude-3-7-sonnet-20250219,2025-02-24,00.0
mistral-large-2411,2024-11-19,00.0
gpt-4o-2024-11-20,2024-11-20,00.0
claude-3-7-sonnet-20250219_16K,2025-02-24,00.0
o1-mini-2024-09-12_medium,2024-09-12,00.0
o1-mini-2024-09-12_high,2024-09-12,00.0
claude-3-5-sonnet-20241022,2024-10-22,00.0
claude-3-5-haiku-20241022,2024-10-22,00.0
gemini-1.5-flash-002,2024-09-24,00.0
gpt-4o-2024-08-06,2024-08-06,00.0
claude-3-5-sonnet-20240620,2024-06-20,00.0
gemini-2.0-flash-001,2024-12-11,00.0
o1-2024-12-17_high,2024-12-17,00.0
gemini-2.0-pro-exp-02-05,2025-02-05,00.0
DeepSeek-V3,2024-12-26,00.0
claude-3-7-sonnet-20250219_32K,2025-02-24,00.0
claude-3-7-sonnet-20250219_64K,2025-02-24,00.0
qwen-max-2025-01-25,2025-01-29,00.0
Llama-4-Scout-17B-16E-Instruct,2025-04-05,00.0
Llama-4-Maverick-17B-128E-Instruct-FP8,2025-04-05,00.0
grok-3-beta,2025-02-17,00.0
grok-3-mini-beta_high,2025-02-17,00.0
grok-3-mini-beta_low,2025-02-17,00.0
gpt-4.1-2025-04-14,2025-04-14,00.0
gpt-4.1-nano-2025-04-14,2025-04-14,00.0
o3-2025-04-16_medium,2025-04-16,00.0
mistral-medium-2505,2025-05-07,00.0
DeepSeek-V3-0324,2024-12-26,00.0
qwen-plus-2025-04-28,2025-04-28,00.0
claude-opus-4-20250514,2025-05-22,00.0
claude-sonnet-4-20250514,2025-05-22,00.0
qwen3-235b-a22b,2025-04-29,00.0
magistral-small-2506,2025-06-10,00.0
gemini-1.5-flash-002,2024-09-24,00.0
Llama-4-Scout-17B-16E-Instruct,2025-04-05,00.0
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-gpqa" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-gpqa"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">GPQA</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://www.vals.ai/benchmarks/gpqa-05-30-2025" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-30
                    </span>
                    <textarea class="hidden">
Lab,Model,Release Date,Score,Cost in/out,Latency
OpenAI,o3 Reasoning Model,2025-04-16,83.6%,$2.00 / $8.00,65.78 s
Google,Gemini 2.5 Pro Exp Reasoning Model,2025-03-25,80.3%,$1.25 / $10.00,41.10 s
xAI,Grok 3 Mini Fast High Reasoning Reasoning Model,2025-02-17,79.0%,$0.60 / $4.00,40.62 s
Anthropic,Claude 3.7 Sonnet (Thinking) Reasoning Model,2025-02-24,75.3%,$3.00 / $15.00,155.02 s
OpenAI,o3 Mini Reasoning Model,2025-01-31,75.0%,$1.10 / $4.40,99.98 s
OpenAI,o4 Mini Reasoning Model,2025-04-16,74.5%,$1.10 / $4.40,30.00 s
Anthropic,Claude Sonnet 4 (Thinking) Reasoning Model,2025-05-22,74.5%,$3.00 / $15.00,118.46 s
xAI,Grok 3 Beta,2025-02-17,73.7%,$3.00 / $15.00,29.91 s
OpenAI,o1 Reasoning Model,2024-09-12,73.0%,$15.00 / $60.00,40.18 s
xAI,Grok 3 Mini Fast Low Reasoning Reasoning Model,2025-02-17,72.7%,$0.60 / $4.00,14.23 s
Anthropic,Claude Opus 4 (Nonthinking),2025-05-22,71.7%,$15.00 / $75.00,19.13 s
Anthropic,Claude Sonnet 4 (Nonthinking),2025-05-22,69.4%,$3.00 / $15.00,12.82 s
Meta,Llama 4 Maverick,2025-04-05,67.7%,$0.27 / $0.85,10.07 s
Anthropic,Claude 3.7 Sonnet (Nonthinking),2025-02-24,67.4%,$3.00 / $15.00,9.22 s
OpenAI,GPT 4.1 Mini,2025-04-14,67.4%,$0.40 / $1.60,9.28 s
Alibaba,Qwen 3 (235B) Reasoning Model,2025-04-29,66.4%,$0.22 / $0.88,306.22 s
Google,Gemini 2.0 Flash (001),2024-12-11,65.2%,$0.10 / $0.40,5.80 s
OpenAI,GPT 4.1,2025-04-14,64.6%,$2.00 / $8.00,23.14 s
DeepSeek,DeepSeek V3 (03/24/2025),2024-12-26,61.1%,$1.20 / $1.20,23.48 s
Anthropic,Claude 3.5 Sonnet Latest,2024-06-20,59.1%,$3.00 / $15.00,7.24 s
Google,Gemini 1.5 Pro (002),2024-09-24,58.3%,$1.25 / $5.00,7.71 s
DeepSeek,DeepSeek V3,2024-12-26,54.0%,$0.90 / $0.90,21.28 s
Google,Gemini 2.5 Flash Preview (Nonthinking),2025-04-17,53.3%,$0.15 / $0.60,43.45 s
OpenAI,GPT 4o (2024-11-20),2024-05-13,53.0%,$2.50 / $10.00,14.92 s
Mistral,Mistral Small (02/2024),2024-02-26,50.8%,$0.20 / $0.60,7.99 s
OpenAI,GPT 4o (2024-05-13),2024-05-13,50.3%,$5.00 / $15.00,10.08 s
Meta,Llama 3.3 Instruct Turbo (70B),2024-12-06,50.0%,$0.88 / $0.88,7.34 s
xAI,Grok 2,2024-08-13,50.0%,$2.00 / $10.00,20.18 s
Google,Gemini 1.5 Flash (002),2024-09-24,46.0%,$0.07 / $0.30,3.39 s
Mistral,Mistral Large (11/2024),2023-09-27,45.2%,$2.00 / $6.00,15.80 s
Meta,Llama 4 Scout,2025-04-05,44.4%,$0.18 / $0.59,12.09 s
OpenAI,GPT 4o Mini,2024-07-18,44.2%,$0.15 / $0.60,15.32 s
Mistral,Mistral Small 3.1 (03/2025),2025-03-17,41.4%,$0.07 / $0.30,8.82 s
OpenAI,GPT 4.1 Nano,2025-04-14,39.9%,$0.10 / $0.40,4.19 s
Anthropic,Claude 3.5 Haiku Latest,2024-10-22,37.9%,$1.00 / $5.00,6.56 s
OpenAI,GPT 3.5,2022-03-15,29.3%,$0.50 / $1.50,2.63 s
Cohere,Command A,2025-03-13,29.3%,$2.50 / $10.00,11.49 s
Cohere,Command R+,2024-08-30,29.0%,$2.50 / $10.00,8.19 s
AI21 Labs,Jamba 1.6 Large,2024-03-29,24.2%,$2.00 / $8.00,15.47 s
AI21 Labs,Jamba 1.6 Mini,2024-03-29,20.5%,$0.20 / $0.40,4.95 s
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <input type="radio" name="menu-selection" id="item-hle" class="menu-radio hidden peer">
                <label for="item-hle"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Humanity's Last Exam</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://lastexam.ai/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-04-17
                    </span>
                    <textarea class="hidden">
Model,Release Date,Accuracy (%)
o3,2025-04-16,20.3
Gemini 2.5 Pro,2025-03-25,18.4
o4-mini,2025-04-16,18.1
o3-mini,2025-01-31,13.4
Gemini 2.5 Flash,2025-04-17,12.1
DeepSeek-R1,2025-01-20,8.5
Claude 3.7 Sonnet (16K),2025-02-24,8.0
o1,2024-09-12,8.0
GPT-4.5 Preview,2025-02-27,5.4
GPT-4.1,2025-04-14,5.4
Claude 3.5 Sonnet,2024-06-20,4.1
GPT-4o,2024-05-13,2.7
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <input type="radio" name="menu-selection" id="item-iq" class="menu-radio hidden peer">
                <label for="item-iq"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">IQ Tests</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://trackingai.org/home" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-10
                    </span>
                    <textarea class="hidden">
Model,Release Date,Offline Test,Mensa Norway,Human percentile (%)
o3,2025-04-16,117,133,87
o3-pro,2025-06-10,116,133,86
Claude-4-Opus,2025-05-22,116,119,86
Gemini 2.5 Pro Exp 06-05,2025-06-05,115,124,84
o3-vision,2025-04-16,109,86,73
Gemini 2.0 Flash Thinking Exp,2024-12-11,108,129,70
o4-mini,2025-04-16,102,126,55
Claude-4-Sonnet,2025-05-22,101,118,53
Gemini 2.5 Pro Exp 06-05 (Vision),2025-06-05,100,96,50
o1-pro,2024-09-12,94,102,34
Claude-4-Sonnet-Vision,2025-05-22,93,97,32
gpt-4.5,2025-02-27,92,97,30
Grok-3-Think,2025-02-17,91,111,27
DeepSeek-R1,2025-01-20,88,105,21
o1-pro-vision,2024-09-12,86,79,18
deepseek-v3,2024-12-26,85,97,16
Grok-3-Think-Vision,2025-02-17,85,62,16
Llama-3 (Vision),2024-04-18,83,70,13
Llama-4,2025-04-05,82,105,12
Claude-4-Opus-Vision,2025-05-22,79,80,8
Mistral,2023-09-27,76,85,5
o4-mini-high,2025-04-16,74,90,4
Grok-3,2025-02-17,73,95,4
GPT4 Omni (Verbal),2023-03-14,69,91,2
GPT4 Omni (Vision),2023-03-14,67,64,1
Bing Copilot,2023-05-04,67,86,1
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-logical" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-logical"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Logical Reasoning</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://llm-benchmark.github.io/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-28
                    </span>
                    <textarea class="hidden">
Model Name,Release Date,Correct Ratio,Accuracy Percentage
o4 mini high 42pt,2025-04-16,3/16,19
Grok 3 Think 38PT,2025-02-17,3/16,18.7
o3 high 35pt,2025-04-16,3/16,18
o3 mini high 22pt,2025-01-31,1/16,6.2
Gemini 2.5 Pro 5pt,2025-03-25,0/16,0
Claude 3.7 Think 16k,2025-02-24,0/16,0
DeepSeek R1 0520 13pt,2025-05-28,1/16,6.2
Claude 4 Opus Think,2025-05-22,0,3
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <input type="radio" name="menu-selection" id="item-mmlu" class="menu-radio hidden peer">
                <label for="item-mmlu"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">MMLU</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://paperswithcode.com/sota/multi-task-language-understanding-on-mmlu" class="click-link text-yellow-400 hover:text-yellow-300 underline">Web</a> 
                        <a href="https://yourgpt.ai/tools/llm-comparison-and-leaderboard" class="click-link text-yellow-400 hover:text-yellow-300 underline">sites</a> | Updated: 2025-04-14
                    </span>
                    <textarea class="hidden">
Model,Release Date,Normalized and capped (%),Normalized (Human=89.8%),Average (%)
o1,2024-09-12,100.0,102.8,92.3
Deepseek-R1,2025-01-20,100.0,101.1,90.8
o1-preview,2024-09-12,100.0,101.1,90.8
GPT-4.1,2025-04-14,100.0,100.4,90.2
Gemini 2.5 Pro,2025-03-25,100.0,100.0,89.8
GPT-4o,2024-05-13,98.8,98.8,88.7
Claude 3.5 Sonnet,2024-06-20,98.8,98.8,88.7
Llama 3.1 405b,2024-07-23,98.7,98.7,88.6
DeepSeek V3,2024-12-26,98.6,98.6,88.5
GPT-4.1 mini,2025-04-14,97.4,97.4,87.5
Grok-2,2024-08-13,97.4,97.4,87.5
Gemini 2.0 Flash,2024-12-11,96.9,96.9,87
Claude 3 Opus,2024-03-04,96.7,96.7,86.8
Llama 3.1 (405B),2024-07-23,96.4,96.4,86.6
GPT-4 Turbo,2024-04-09,96.3,96.3,86.5
GPT-4,2023-03-14,96.2,96.2,86.4
Claude 3.7 Sonnet,2025-02-24,95.9,95.9,86.1
Llama 3.1 (70B),2024-07-23,95.8,95.8,86
Llama 3.2 90B,2024-09-25,95.8,95.8,86
Llama 3.3 70B,2024-12-06,95.8,95.8,86
o3-mini,2025-01-31,95.8,95.8,86
o1-mini,2024-09-12,94.9,94.9,85.2
Llama 4 Maverick,2025-04-05,94.2,94.2,84.6
Gemini Ultra (5-shot),2024-02-08,93.2,93.2,83.7
Claude 3.7 Sonnet(Normal),2025-02-24,92.7,92.7,83.2
GPT-4o mini,2024-07-18,91.3,91.3,82
Gemini 1.5 Pro,2024-02-15,91.2,91.2,81.9
GPT-4.1 nano,2025-04-14,89.2,89.2,80.1
Gemini 2.0 Pro Experimental,2025-02-05,88.1,88.1,79.1
Claude 3 Sonnet (5-shot),2024-03-13,88.0,88.0,79
Claude 3 Sonnet,2024-03-04,88.0,88.0,79
Gemini 1.5 Flash,2024-02-15,87.9,87.9,78.9
Qwen1.5 72B (5-shot),2024-02-04,86.3,86.3,77.5
Claude 3 Haiku (5-shot),2024-03-13,83.7,83.7,75.2
Claude 3 Haiku,2024-03-13,83.7,83.7,75.2
Llama 4 Scout,2025-04-05,82.7,82.7,74.3
DBRX Instruct 132B (5-shot),2024-03-27,82.1,82.1,73.7
llama 2(65b),2023-07-01,81.8,81.8,73.5
Llama 3.1 8B (CoT),2024-07-23,81.3,81.3,73
Mixtral 8x7B (5-shot),2023-12-09,78.6,78.6,70.6
GPT-3.5 Turbo,2024-01-25,78.0,78.0,70
LLaMA 65B (fine-tuned),2023-02-24,76.7,76.7,68.9
chatgpt/gpt3.5(20B),2022-03-15,75.2,75.2,67.5
Claude 3.5 Haiku,2024-10-22,72.4,72.4,65
LLaMA 65B (5-shot),2023-02-24,70.6,70.6,63.4
LLaMA 2 34B (5-shot),2023-07-01,69.7,69.7,62.6
Mistral 7B (5-shot),2023-09-27,69.6,69.6,62.5
Mistral 7B (5-shot),2023-09-27,66.9,66.9,60.1
GPT-3 Davinci 175B (CoT),2020-06-11,66.3,66.3,59.5
LLaMA 33B (5-shot),2024-12-06,64.4,64.4,57.8
Falcon 40B,2023-03-17,63.5,63.5,57
Qwen 7B (5-shot),2023-09-13,63.1,63.1,56.7
LLaMA 2 13B (5-shot),2023-07-01,61.0,61.0,54.8
GPT 3,2020-06-11,54.5,54.5,48.9
Flan-T5-XL 3B (CoT),2022-10-20,50.7,50.7,45.5
LLaMA 2 7B (5-shot),2023-07-01,50.4,50.4,45.3
Flan-T5-Large 780M,2022-10-20,50.2,50.2,45.1
GPT-3 175B (fine-tuned),2020-06-11,48.9,48.9,43.9
GPT-3 175B (5-shot),2020-06-11,48.9,48.9,43.9
Flan-T5-Large 780M (CoT),2022-10-20,45.1,45.1,40.5
GPT-3 Davinci 175B (5-shot),2020-06-11,44.2,44.2,39.7
phi-1.5-web 1.3B,2023-09-10,42.2,42.2,37.9
OPT 66B (5-shot),2022-06-23,40.1,40.1,36
Flan-T5-Base 250M,2022-10-20,40.0,40.0,35.9
Flan-T5-Base 250M (CoT),2022-10-20,37.5,37.5,33.7
GPT-NeoX 20B (5-shot),2022-04-07,37.4,37.4,33.6
GPT-2-XL 1.5B (fine-tuned),2019-11-05,36.1,36.1,32.4
LLaMA7B-MiLe-Loss(5-shot),2023-02-24,33.1,33.1,29.68
Flan-T5-Small 80M,2022-10-20,32.0,32.0,28.7
Falcon 7B (5-shot),2023-05-25,31.2,31.2,28
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <input type="radio" name="menu-selection" id="item-mmlu-pro" class="menu-radio hidden peer">
                <label for="item-mmlu-pro"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">MMLU Pro</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://www.vals.ai/benchmarks/mmlu_pro-05-30-2025" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-30
                    </span>
                    <textarea class="hidden">
Lab,Model,Release Date,Accuracy,Cost In/Out,Latency
Anthropic,Claude Opus 4 (Nonthinking),2025-05-22,86.1%,$15.00 / $75.00,10.41 s
OpenAI,o3,2025-04-16,85.6%,$10.00 / $40.00,16.74 s
Google,Gemini 2.5 Pro Exp,2025-03-25,84.1%,$1.25 / $10.00,18.46 s
Anthropic,Claude Sonnet 4 (Thinking),2025-05-22,83.8%,$3.00 / $15.00,47.09 s
OpenAI,o1,2024-09-12,83.5%,$15.00 / $60.00,26.87 s
Anthropic,Claude 3.7 Sonnet (Thinking),2025-02-24,82.7%,$3.00 / $15.00,31.74 s
xAI,Grok 3 Mini Fast High Reasoning,2025-02-17,81.4%,$0.60 / $4.00,16.89 s
Anthropic,Claude 3.7 Sonnet (Nonthinking),2025-02-24,80.7%,$3.00 / $15.00,6.30 s
OpenAI,o4 Mini,2025-04-16,80.6%,$1.10 / $4.40,10.44 s
OpenAI,GPT 4.1,2025-04-14,80.5%,$2.00 / $8.00,8.18 s
Alibaba,Qwen 3 (235B),2025-04-29,80.4%,$1.20 / $1.20,52.35 s
xAI,Grok 3 Mini Fast Low Reasoning,2025-02-17,80.0%,$0.60 / $4.00,7.43 s
xAI,Grok 3 Beta,2025-02-17,79.9%,$3.00 / $15.00,12.10 s
Anthropic,Claude Sonnet 4 (Nonthinking),2025-05-22,79.4%,$3.00 / $15.00,9.71 s
Meta,Llama 4 Maverick,2025-04-05,79.4%,$0.27 / $0.85,6.80 s
DeepSeek,DeepSeek V3 (03/24/2025),2024-12-26,78.9%,$1.20 / $1.20,25.05 s
OpenAI,o3 Mini,2025-01-31,78.7%,$1.10 / $4.40,22.38 s
Anthropic,Claude 3.5 Sonnet Latest,2024-06-20,78.4%,$3.00 / $15.00,6.29 s
Google,Gemini 2.0 Flash (001),2024-12-11,77.4%,$0.10 / $0.40,4.32 s
OpenAI,GPT 4.1 mini,2025-04-14,77.2%,$0.40 / $1.60,3.83 s
xAI,Grok 2,2024-08-13,75.5%,$2.00 / $10.00,8.75 s
Google,Gemini 1.5 Pro (002),2024-09-24,75.3%,$1.25 / $5.00,3.34 s
Mistral,Mistral Medium 3.1 (05/2025),2025-05-07,74.4%,$0.40 / $2.00,8.83 s
OpenAI,GPT 4o (2024-08-06),2024-05-13,74.1%,$2.50 / $10.00,9.00 s
DeepSeek,DeepSeek V3,2024-12-26,73.8%,$0.90 / $0.90,11.36 s
DeepSeek,DeepSeek R1,2025-01-20,71.1%,$8.00 / $8.00,27.28 s
Meta,Llama 3.3 Instruct Turbo (70B),2024-12-06,69.9%,$0.88 / $0.88,4.18 s
Mistral,Mistral Large 2 (2411),2024-11-19,69.7%,$2.00 / $6.00,7.19 s
Meta,Llama 4 Scout,2025-04-05,69.6%,$0.18 / $0.59,5.34 s
OpenAI,GPT 4o (2024-11-20),2024-05-13,69.1%,$2.50 / $10.00,9.14 s
Mistral,Mistral Small 3.1 (03/2025),2025-03-17,66.0%,$0.07 / $0.30,3.60 s
Google,Gemini 1.5 Flash (002),2024-09-24,65.5%,$0.07 / $0.30,1.68 s
Cohere,Command A,2025-03-13,65.2%,$2.50 / $10.00,9.85 s
Mistral,Mistral Small (02/2024),2024-02-26,64.4%,$0.20 / $0.60,4.66 s
Anthropic,Claude 3.5 Haiku Latest,2024-10-22,64.1%,$1.00 / $5.00,5.79 s
OpenAI,GPT 4o Mini,2024-07-18,62.7%,$0.15 / $0.60,5.09 s
OpenAI,GPT 4.1 nano,2025-04-14,62.3%,$0.10 / $0.40,2.40 s
AI21 Labs,Jamba 1.6 Large,2024-03-29,49.3%,$2.00 / $8.00,9.48 s
Cohere,Command R+,2024-08-30,43.9%,$2.50 / $10.00,4.42 s
AI21 Labs,Jamba 1.6 Mini,2024-03-29,30.2%,$0.20 / $0.40,2.43 s
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-nocha" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-nocha"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Novel Challenge (NOCHA)</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://novelchallenge.github.io/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-04-29
                    </span>
                    <textarea class="hidden">
Model,Release Date,Accuracy,# Correct pairs,# Attempted pairs
o1-preview [09/12],2024-09-12,67.36%,324,481
Gemini 2.5 Pro [03/25-exp],2025-03-25,64.17%,745,1161
o1-high [12/17],2024-09-12,63.68%,682,1071
DeepSeek R1 MoE,2025-01-20,58.57%,533,910
GPT-4o [05/13],2024-05-13,55.75%,344,617
GPT-4o [08/06],2024-05-13,55.60%,402,723
Gemini 1.5 Pro [08/01-exp],2024-08-01,49.14%,370,753
Claude-3.5-Sonnet v2 [10/22],2024-10-22,48.88%,458,937
Gemini 1.5 Pro [08/27-exp],2024-08-27,48.29%,439,909
Claude-3-Opus [02/29],2024-02-29,48.11%,522,1085
Gemini 1.5 Pro [05/14],2024-05-14,48.05%,247,514
Gemini Flash 2.0 exp,2024-12-11,47.23%,461,976
LLaMA 3.1 405B,2024-07-23,47.21%,347,735
Qwen 3.0 32B thinking,2025-04-29,47.03%,325,691
o4-mini [04/16],2025-04-16,46.81%,513,1096
Llama 4 Maverick 400B MoE,2025-04-05,43.99%,512,1164
Qwen 2 72B,2024-07-23,43.35%,264,609
MiniMax-Text-01,,43.29%,503,1162
Qwen 2.5 72B,2024-09-19,41.71%,254,609
Claude-3.5-Sonnet [06/20],2024-06-20,40.37%,438,1085
GPT-4-Turbo [04/09],2024-04-09,38.31%,277,723
Claude-3.5-Haiku [10/22],2024-10-22,35.01%,328,937
LLaMA 3.3 70B,2024-12-06,34.99%,253,723
Gemini 1.5 Flash [05/14],2024-05-14,34.17%,176,515
Gemini 1.5 Flash [08/27-exp],2024-08-27,33.88%,308,909
GPT-4o-Mini [07/18],2024-07-18,33.06%,239,723
Gemma 3.0 27B,2025-03-10,32.48%,190,585
DeepSeek-R1-Distill-Qwen-32B,2025-01-20,31.84%,220,691
Qwen 3.0 32B,2025-04-29,31.81%,230,723
Qwen 2.5 14B,2024-09-19,30.05%,183,609
Qwen2.5 14B Instruct 1M,2024-09-19,29.30%,341,1164
o1-mini [09/12],2024-09-12,28.60%,155,542
LLaMA 3.1 70B,2024-07-23,27.89%,205,735
GLM4 9B 1M,,27.07%,271,1001
Jamba 1.5 Mini,2024-03-29,27.00%,301,1115
Jamba 1.5 Large,2024-03-29,26.55%,296,1115
Gemini 1.5 Flash 8B [08/27-exp],2024-08-27,26.20%,240,916
Qwen2.5 7B Instruct 1M,2024-09-19,26.20%,305,1164
DeepSeek-R1-Distill-Qwen-14B,2025-01-20,24.31%,168,691
Llama 4 Scout 109B MoE,2025-04-05,24.16%,274,1134
Qwen 2.5 7B,2024-09-19,24.14%,147,609
Command R (simple),2024-03-11,22.47%,100,445
LLaMA 3.2 3B,2024-09-25,21.56%,133,617
Command R,2024-03-11,19.55%,87,445
MegaBeam-Mistral-7B-512k,2024-07-30,18.54%,180,971
Command R+,2024-08-30,17.30%,77,445
Llama 3 8B ProLong-512k-Instruct,2024-04-18,16.88%,169,1001
LLaMA 3.1 8B,2024-07-23,16.53%,102,617
LLaMA-3 70B 1M (GradientAI),2024-04-18,16.08%,161,1001
Phi 3.5 Mini,2024-08-22,16.01%,53,331
Phi 3 Medium,2024-04-23,14.80%,49,331
Qwen 2.5 1.5B,2024-09-19,14.78%,90,609
Qwen 2.5 3B,2024-09-19,14.78%,90,609
Phi-3-Mini (simple),2024-04-23,14.50%,48,331
Mistral-Large 2,2024-11-19,14.02%,30,214
Command R+ (simple),2024-08-30,13.71%,61,445
LLaMA-3 8B 1M (GradientAI),2024-04-18,13.09%,131,1001
Phi 3 Mini,2024-04-23,9.31%,23,247
Qwen 2.5 0.5B,2024-09-19,8.05%,49,609
Gemma-10M (simple),2024-05-07,7.49%,75,1001
LongLLaMA (simple),,4.91%,46,937
Gemma-10M,2024-05-07,3.90%,39,1001
LLaMA 3.2 1B,2024-09-25,2.43%,15,617
Mistral-Nemo,2024-07-18,2.11%,13,617
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-nyt" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-nyt"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">NYT Connections (Ext'd)</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://github.com/lechmazur/nyt-connections?tab=readme-ov-file#leaderboard-extended-version" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-10
                    </span>
                    <textarea class="hidden">
Model,Release Date,Score %,#Puzzles
o3-pro (medium reasoning),2025-06-10,87.3,651
o1-pro (medium reasoning),2024-09-12,82.5,651
o3 (high reasoning),2025-04-16,79.5,651
o4-mini (high reasoning),2025-04-16,74.7,651
o3 (medium reasoning),2025-04-16,74.0,651
o1 (medium reasoning),2024-09-12,70.8,651
o4-mini (medium reasoning),2025-04-16,68.8,651
o3-mini (high reasoning),2025-01-31,61.4,651
Gemini 2.5 Pro Preview 06-05,2025-06-05,58.7,651
Qwen 3 235B A22B,2025-04-29,55.6,651
Gemini 2.5 Pro Exp 03-25,2025-03-25,54.1,651
o3-mini (medium reasoning),2025-01-31,53.6,651
Claude Opus 4 Thinking 16K,2025-05-22,52.7,651
DeepSeek R1 05/28,2025-01-20,49.8,651
Gemini 2.5 Pro Preview 05-06,2025-06-05,42.5,651
Claude Sonnet 4 Thinking 16K,2025-05-22,41.4,651
Claude Sonnet 4 Thinking 64K,2025-05-22,39.6,651
DeepSeek R1,2025-01-20,38.6,651
Qwen 3 30B A3B,2025-04-29,38.0,651
Claude Opus 4 (no reasoning),2025-05-22,34.8,651
GPT-4.5 Preview,2025-02-27,34.2,651
Claude 3.7 Sonnet Thinking 16K,2025-02-24,33.6,651
Qwen QwQ-32B 16K,2025-03-05,31.4,651
Grok 3 Mini Beta (high),2025-02-17,30.9,651
o1-mini,2024-09-12,26.9,651
Grok 3 Mini Beta (low),2025-02-17,26.0,651
Gemini 2.5 Flash Preview (24k),2025-04-17,25.8,651
Claude Sonnet 4 (no reasoning),2025-05-22,25.7,651
Quasar Alpha,2025-04-04,25.4,651
GPT-4o Mar 2025,2025-03-26,25.2,651
GPT-4.1,2025-04-14,23.6,651
Gemini 2.0 Flash Think Exp 01-21,2024-12-11,23.1,649
GPT-4o Feb 2025,2025-02-18,22.7,651
Gemini 2.0 Pro Exp 02-05,2025-02-05,21.7,651
Grok 3 Beta (no reasoning),2025-02-17,20.3,651
Grok 2 12-12,2024-08-13,19.2,651
Gemini 1.5 Pro (Sept),2024-09-24,19.2,601
Claude 3.7 Sonnet,2025-02-24,19.2,651
Claude 3 Opus,2024-03-04,19.2,651
Llama 4 Maverick,2025-04-05,19.1,651
Gemini 2.0 Flash,2024-12-11,18.8,651
GPT-4o 2024-11-20,2024-11-20,18.7,601
Qwen 2.5 Max,2025-01-29,18.0,651
Llama 4 Scout,2025-04-05,17.9,651
GPT-4o 2024-08-06,2024-08-06,17.8,601
Claude 3.5 Sonnet 2024-10-22,2024-06-20,17.7,651
DeepSeek V3-0324,2024-12-26,17.4,651
Llama 3.1 405B,2024-07-23,16.2,651
DeepSeek V3,2024-12-26,15.1,651
Llama 3.3 70B,2024-12-06,15.1,651
GPT-4.1 mini,2025-04-14,15.1,651
MiniMax-Text-01,2025-01-12,14.6,651
Cohere Command A,2025-03-13,13.6,651
Mistral Large 2,2024-11-19,12.6,651
Gemma 2 27B,2024-06-27,12.2,651
Gemma 3 27B,2025-03-10,11.8,651
Mistral Medium 3,2025-05-07,11.4,651
Mistral Small 3.1,2025-03-17,11.4,651
Qwen 2.5 72B,2024-09-19,11.1,651
Claude 3.5 Haiku,2024-10-22,10.3,651
Microsoft Phi-4,2024-12-12,10.2,651
Amazon Nova Pro,2024-12-03,10.1,651
GPT-4o mini,2024-07-18,9.9,651
Mistral Small 3,2025-01-30,8.9,601
GPT-4.1 nano,2025-04-14,8.6,651
Claude 3 Haiku,2024-03-13,2.2,601
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-simple" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-simple"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">SimpleBench</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://simple-bench.com/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-06-05
                    </span>
                    <textarea class="hidden">
Model,Release Date,Score (AVG@5),Organization
Human Baseline,,83.7%,
Gemini 2.5 Pro (06-05),2025-06-05,62.4%,Google
Claude 4 Opus (thinking),2025-05-22,58.8%,Anthropic
o3 (high),2025-04-16,53.1%,OpenAI
Gemini 2.5 Pro,2025-03-25,51.6%,Google
Claude 3.7 Sonnet (thinking),2025-02-24,46.4%,Anthropic
Claude 4 Sonnet (thinking),2025-05-22,45.5%,Anthropic
Claude 3.7 Sonnet,2025-02-24,44.9%,Anthropic
o1-preview,2024-09-12,41.7%,OpenAI
Claude 3.5 Sonnet 10-22,2024-06-20,41.4%,Anthropic
DeepSeek R1 05/28,2025-01-20,40.8%,DeepSeek
o1-2024-12-17 (high),2024-09-12,40.1%,OpenAI
o4-mini (high),2025-04-16,38.7%,OpenAI
o1-2024-12-17 (med),2024-09-12,36.7%,OpenAI
Grok 3,2025-02-17,36.1%,xAI
GPT-4.5,2025-02-27,34.5%,OpenAI
Gemini-exp-1206,2024-12-17,31.1%,Google
Qwen3 235B-A22B,2025-04-29,31.0%,Alibaba
DeepSeek R1,2025-01-20,30.9%,DeepSeek
Gemini 2.0 Flash Thinking,2024-12-11,30.7%,Google
Llama 4 Maverick,2025-04-05,27.7%,Meta
Claude 3.5 Sonnet 06-20,2024-06-20,27.5%,Anthropic
DeepSeek V3 03-24,2024-12-26,27.2%,DeepSeek
Gemini 1.5 Pro 002,2024-09-24,27.1%,Google
GPT-4.1,2025-04-14,27.0%,OpenAI
GPT-4 Turbo,2024-04-09,25.1%,OpenAI
Claude 3 Opus,2024-03-04,23.5%,Anthropic
Llama 3.1 405b instruct,2024-07-23,23.0%,Meta
o3-mini (high),2025-01-31,22.8%,OpenAI
Grok 2,2024-08-13,22.7%,xAI
Mistral Large v2,2024-11-19,22.5%,Mistral
Llama 3.3 70b instruct,2024-12-06,19.9%,Meta
DeepSeek V3,2024-12-26,18.9%,DeepSeek
Gemini 2.0 Flash Exp,2024-12-11,18.9%,Google
o1-mini,2024-09-12,18.1%,OpenAI
GPT-4o 08-06,2024-05-13,17.8%,OpenAI
Command R+,2024-08-30,17.4%,Cohere
GPT-4o mini,2024-07-18,10.7%,OpenAI
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-simplemini" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-simplemini"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">SimpleBench mini</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://wandb.ai/simplebench/simple_bench_public/weave/traces?sort=%5B%7B%22field%22%3A%22started_at%22%2C%22sort%22%3A%22desc%22%7D%5D&amp;view=traces_default&amp;filters=%7B%22items%22%3A%5B%7B%22id%22%3A0%2C%22field%22%3A%22output.eval_multi_choice.true_count%22%2C%22operator%22%3A%22%28string%29%3A+contains%22%2C%22value%22%3A%2219%22%7D%5D%2C%22logicOperator%22%3A%22and%22%7D" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-01-19
                    </span>
                    <textarea class="hidden">
Model,Release Date,Score (AVG@5),Organization
Human Baseline,2024-10-31,83.7%,SimpleBench
Gemini 1.5 Pro + Custom Prompt,2025-01-19,95%,Google + Prompter
                    </textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <input type="radio" name="menu-selection" id="item-swebench" class="menu-radio hidden peer">
                <label for="item-swebench"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">SWE Bench (Verified)</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://www.swebench.com/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-22
                    </span>
<textarea class="hidden">
Model,% Resolved,Date
Tools + Claude 4 Opus (2025-05-22),73.20,2025-05-22
Tools + Claude 4 Sonnet (2025-05-22),72.40,2025-05-22
TRAE,70.60,2025-05-19
OpenHands + Claude 4 Sonnet,70.40,2025-05-24
Refact.ai Agent,70.40,2025-05-15
devlo,70.20,2025-05-19
Zencoder (2025-04-30),70.00,2025-04-30
Nemotron-CORTEXA,68.20,2025-05-16
SWE-agent + Claude 4 Sonnet,66.60,￼2025-05-22
Aime-coder v1 + Anthopic Claude 3.7 Sonnet,66.40,2025-05-14
OpenHands,65.80,2025-04-15
Amazon Q Developer Agent (v20250405-dev),65.40,2025-04-05
Augment Agent v0,65.40,2025-03-16
W&amp;B Programmer O1 crosscheck5,64.60,2025-01-17
AgentScope,63.40,2025-02-06
Tools + Claude 3.7 Sonnet (2025-02-24),63.20,2025-02-24
Blackbox AI Agent,62.80,2025-01-10
EPAM AI/Run Developer Agent v20250219 + Anthopic Claude 3.5 Sonnet,62.80,2025-02-28
CodeStory Midwit Agent + swe-search,62.20,2024-12-21
OpenHands + 4x Scaled (2024-02-03),60.80,2025-02-03
Learn-by-interact,60.20,2025-01-10
devlo,58.20,2024-12-13
Emergent E1 (v2024-12-23),57.20,2024-12-23
Gru(2024-12-08),57.00,2024-12-08
EPAM AI/Run Developer Agent v20241212 + Anthopic Claude 3.5 Sonnet,55.40,2024-12-12
Amazon Q Developer Agent (v20241202-dev),55.00,2024-12-02
devlo,54.20,2024-11-08
Bracket.sh,53.20,2025-01-20
OpenHands + CodeAct v2.1 (claude-3-5-sonnet-20241022),53.00,2024-10-29
Google Jules + Gemini 2.0 Flash (v20241212-experimental),52.20,2024-12-12
Engine Labs (2024-11-25),51.80,2024-11-25
AutoCodeRover-v2.1 (Claude-3.5-Sonnet-20241022),51.60,2025-01-22
Agentless-1.5 + Claude-3.5 Sonnet (20241022),50.80,2024-12-02
Solver (2024-10-28),50.00,2024-10-28
Bytedance MarsCode Agent,50.00,2024-11-25
nFactorial (2024-11-05),49.20,2024-11-05
Tools + Claude 3.5 Sonnet (2024-10-22),49.00,2024-10-22
Composio SWE-Kit (2024-10-25),48.60,2024-10-25
AppMap Navie v2,47.20,2024-11-06
Emergent E1 (v2024-10-12),46.60,2024-10-23
AutoCodeRover-v2.0 (Claude-3.5-Sonnet-20241022),46.20,2024-11-08
Solver (2024-09-12),45.40,2024-09-24
Gru(2024-08-24),45.20,2024-08-24
CodeShellAgent + Gemini 2.0 Flash (Experimental),44.20,2025-01-18
Solver (2024-09-12),43.60,2024-09-20
Agentless Lite + O3 Mini (20250214),42.40,2025-02-14
ugaiforge,41.60,2025-01-12
nFactorial (2024-10-30),41.60,2024-10-30
SWE-RL (Llama3-SWE-RL-70B + Agentless Mini) (20250226),41.20,2025-02-26
Nebius AI Qwen 2.5 72B Generator + LLama 3.1 70B Critic,40.60,2024-11-13
Tools + Claude 3.5 Haiku,40.60,2024-10-22
Honeycomb,40.60,2024-08-20
Composio SWEkit + Claude 3.5 Sonnet (2024-10-16),40.60,2024-10-16
EPAM AI/Run Developer Agent v20241029 + Anthopic Claude 3.5 Sonnet,39.60,2024-10-29
Amazon Q Developer Agent (v20240719-dev),38.80,2024-07-21
Agentless-1.5 + GPT 4o (2024-05-13),38.80,2024-10-28
AutoCodeRover (v20240620) + GPT 4o (2024-05-13),38.40,2024-06-28
SWE-agent + Claude 3.5 Sonnet,33.60,2024-06-20
MASAI + GPT 4o (2024-06-12),32.60,2024-06-12
Artemis Agent v1 (2024-11-20),32.00,2024-11-20
nFactorial (2024-10-07),31.60,2024-10-07
SWE-Fixer (Qwen2.5-7b retriever + Qwen2.5-72b editor) 20241128,30.20,2024-11-28
Lingma Agent + Lingma SWE-GPT 72b (v0925),28.80,2024-10-02
EPAM AI/Run Developer Agent + GPT4o,27.00,2024-10-16
AppMap Navie + GPT 4o (2024-05-13),26.20,2024-06-15
nFactorial (2024-10-01),25.80,2024-10-01
Amazon Q Developer Agent (v20240430-dev),25.60,2024-05-09
Lingma Agent + Lingma SWE-GPT 72b (v0918),25.00,2024-09-18
EPAM AI/Run Developer Agent + GPT4o,24.00,2024-08-20
SWE-agent + GPT 4o (2024-05-13),23.20,2024-07-28
SWE-agent + GPT 4 (1106),22.40,2024-04-02
SWE-agent + Claude 3 Opus,18.20,2024-04-02
Lingma Agent + Lingma SWE-GPT 7b (v0925),18.20,2024-10-02
Lingma Agent + Lingma SWE-GPT 7b (v0918),10.20,2024-09-18
RAG + Claude 3 Opus,7.00,2024-04-02
RAG + Claude 2,4.40,2023-10-10
RAG + GPT 4 (1106),2.80,2024-04-02
RAG + SWE-Llama 7B,1.40,2023-10-10
RAG + SWE-Llama 13B,1.20,2023-10-10
RAG + ChatGPT 3.5,0.40,2023-10-10
</textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <input type="radio" name="menu-selection" id="item-taubench" class="menu-radio hidden peer">
                <label for="item-taubench"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">TAU Bench (Airline)</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://www.tau-bench.com/" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-22
                    </span>
<textarea class="hidden">
Date,Model,Pass^1
2025-05-22,Claude 4 Opus,59.6
2025-05-22,Claude 4 Sonnet,60.0
2024-10-22,claude-3-5-sonnet-20241022,46.0
2024-07-18,gpt-4o-mini,22.5
2024-06-17,gpt-4o,42.0
2024-06-17,gpt-4o,36.5
2024-06-17,gpt-4o,32.5
2024-04-10,claude-3-5-sonnet-20240620,36.0
</textarea>
                </label>
            </li>
            <li class="sidebar-nav-text">
                <!-- Invisible radio button to store state, marked as 'peer' -->
                <input type="radio" name="menu-selection" id="item-vending" class="menu-radio hidden peer">
                <!-- Label acts as the clickable button -->
                <label for="item-vending"
                       class="menu-label block p-3 bg-gray-700 hover:bg-gray-600
                              border-2 border-gray-600 hover:border-gray-500
                              rounded-md cursor-pointer
                              transition-all duration-300 ease-in-out
                              overflow-hidden
                              peer-checked:bg-blue-600 peer-checked:border-blue-700 peer-checked:text-white">
                    <span class="menu-item-title block font-bold">Vending-Bench</span>
                    <span class="menu-item-extra block text-sm text-gray-300
                                 mt-0 max-h-0 opacity-0 overflow-hidden
                                 transition-all duration-400 ease-in-out">
                        <a href="https://andonlabs.com/evals/vending-bench" class="click-link text-yellow-400 hover:text-yellow-300 underline">Website</a> | Updated: 2025-05-22
                    </span>
                    <textarea class="hidden">
Model,Release Date,Net worth (mean),Net worth (min),Units sold (mean),Units sold (min),Days until sales stop (mean),Days until sales stop (% of run)
Claude Opus 4,2025-05-22,$2071.15,$1249.56,1373,1218,133,99.5%
Human*,,$844.05,$844.05,344,344,67,100%
Gemini 2.5 Pro (preview-03-25),2025-03-25,$789.34,$691.68,356,313,68,89%
Claude 3.5 Sonnet,2024-06-20,$2217.93,$476.00,1560,0,102,82.2%
Gemini 1.5 Flash,2024-02-15,$571.85,$476.00,89,0,15,42.4%
Claude Sonnet 4,2025-05-22,$968.31,$444.00,538,0,80,80.6%
Gemini 1.5 Pro,2024-02-15,$594.02,$439.20,375,0,35,43.8%
GPT-4o mini,2024-07-18,$582.33,$420.50,473,65,71,73.2%
o3-mini,2025-01-31,$906.86,$369.05,831,0,86,80.3%
Claude 3.7 Sonnet,2025-02-24,$1567.90,$276.00,1050,0,112,80.3%
Gemini 2.0 Pro,2025-02-05,$273.70,$273.70,118,118,25,15.8%
GPT-4o,2024-05-13,$335.46,$265.65,258,108,65,50.3%
Claude 3.5 Haiku,2024-10-22,$373.36,$264.00,23,0,8,12.9%
Gemini 2.0 Flash,2024-12-11,$338.08,$157.25,104,0,50,55.7%
                    </textarea>
                </label>
            </li>
        </ul>
    </aside>

      <main class="flex-1 p-8 transition-all duration-300 ease-in-out ml-80 peer-checked:ml-20 bg-slate-100 min-h-screen">
      
        <h1 class="text-3xl font-bold mb-4 text-primary dark:text-primary">Benchmark Plotter</h1>
        
        <div id="inputContainer" class="mb-6">
            <label for="dataInput" class="block mb-2 font-medium">Paste your benchmark data below. The supported formats are <abbr title="Comma Separated Values">CSV</abbr>, <abbr title="Tab Separated Values">TSV</abbr>, <span title="Using browser tools, e.g. &lt;thead&gt;&lt;tr&gt;&lt;th&gt;...">innerHTML</span>, <span title="Using browser tools, e.g. &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;...">outerHTML</span>, and copy-pasted text from a rendered HTML table. Alternatively, select a benchmark from the menu.</label>
            <textarea id="dataInput" rows="10" autofocus class="w-full p-3 border rounded-lg text-base dark:bg-gray-800 dark:border-gray-700 border-gray-300"></textarea>
            <div class="flex mt-3">
                <button id="parseButton" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg transition">Parse Data</button>
                <button id="clearButton" class="px-4 py-2 ml-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition">Clear</button>
                <button id="hideInputButton" class="px-4 py-2 ml-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition hidden">Hide Input</button>
            </div>
        </div>
        
        <div id="showInputContainer" class="mb-6 flex items-center hidden">
            <button id="showInputButton" class="px-4 py-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition">Show Input</button>
            <button id="resetButton" class="px-4 py-2 ml-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition">Reset</button>
        </div>
        
        <div id="formatDetectionMessage" class="hidden p-4 my-4 bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 rounded-lg"></div>
        
        <div id="loadingIndicator" class="hidden my-4 text-center">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
            <p class="mt-2">Analyzing data pattern...</p>
        </div>
        
        <div id="errorMessage" class="hidden p-4 my-4 bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-200 rounded-lg"></div>
        
        <div id="resultSection" class="hidden">
            <h2 class="text-2xl font-bold mb-3">Parsed Table</h2>
            <div id="formatInfo" class="pattern-info mb-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-lg">
                <p id="patternInfo" class="mb-2"></p>
                <p id="tableStructure"></p>
            </div>
            
            <div id="columnActionContainer" class="mb-3 hidden">
                <div class="flex items-center">
                    <button id="toggleColumnsButton" class="px-4 py-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition disabled:cursor-not-allowed">Select Columns</button>
                    <button id="deleteColumnsButton" class="px-4 py-2 ml-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition disabled:cursor-not-allowed" disabled>Delete Columns</button>
                    <button id="addDateColumnButton" class="px-4 py-2 ml-2 bg-primary hover:bg-opacity-80 text-white rounded-lg transition hidden">Add Date Column</button>
                    <p id="columnSelectionError" class="ml-3 text-red-600 dark:text-red-400 hidden">At least 2 columns must remain in the table</p>
                </div>
            </div>
            
            <div id="truncatedTableContainer" class="truncated-table-container">
                <div id="tableContainer" class="table-container"></div>
                
                <div class="fade-overlay" id="fadeOverlay"></div>

                <div class="button-container">
                    <button class="toggle-button" id="toggleButton" type="button" aria-label="Show more rows" aria-expanded="false">
                        <svg id="iconDown" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                        </svg>
                        <svg id="iconUp" class="hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                        </svg>
                    </button>
                </div>
            </div>
            <div class="mt-4 text-center space-x-2">
                <button id="toggleHeadersButton" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg transition hidden">
                    Keep Headings
                </button>
                <button id="convertToCsvButton" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg transition">
                    Convert to CSV
                </button>
                <button id="convertToJsonButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition">
                    Convert to JSON
                </button>
                <button id="drawChartButton" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition">
                    Draw Chart
                </button>
            </div>
            
            <div id="exportOutputContainer" class="mt-6 hidden">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-xl font-bold"><span id="exportFormatLabel">CSV</span> Output</h3>
                    <div class="flex space-x-2">
                        <button id="copyOutputButton" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm rounded-lg transition">
                            Copy to Clipboard
                        </button>
                        <button id="closeOutputButton" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm rounded-lg transition">
                            Hide
                        </button>
                    </div>
                </div>
                <textarea id="exportOutput" rows="8" class="w-full p-3 border rounded-lg font-mono text-sm dark:bg-gray-800 dark:border-gray-700 border-gray-300" readonly></textarea>
            </div>
            
            <!-- Chart container -->
            <div id="chartContainer" class="mt-6 hidden">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-xl font-bold">Chart</h3>
                    <div class="flex space-x-2">
                        <div id="frontierControlContainer" class="flex items-center">
                            <label for="frontierToggleCheckbox" class="mr-2 text-sm">Improvements only:</label>
                            <input type="checkbox" id="frontierToggleCheckbox" class="w-4 h-4" checked>
                        </div>
                        <button id="downloadChartButton" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm rounded-lg transition">
                            Download
                        </button>
                        <a id="hiddenLink" class="hidden" href="" download="benchmark.png"></a><!-- Store the image data here when the chart is updated -->
                        <button id="closeChartButton" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm rounded-lg transition">
                            Hide Chart
                        </button>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="chartCanvas"></canvas>
                </div>
                <!-- Added formula container for regression line -->
                <div id="chartFormulaContainer" class="mt-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-lg text-center hidden">
                    <p id="trendlineFormula" class="font-mono text-lg"></p>
                    <p id="interceptInfo" class="mt-2 text-sm"></p>
                </div>
            </div>
        </div>
        
        <!-- Toast notification for chart errors -->
        <div id="chartErrorToast" class="toast">
            <span id="chartErrorMessage">Error message goes here</span>
        </div>
    </main>

    <script>
        // Hardcoded data, connecting model names (lower case) with their release dates
        // Remove punction and split the name into tokens that are: "just digits" or "just letters" or "digit-letter/letter-digit pair"
        const modelDates = {
            "alpaca 7b": "2023-03-13",
            "bing copilot": "2023-05-04",
            "claude 3 haiku": "2024-03-13",
            "claude 3 opus": "2024-03-04",
            "claude 3 sonnet": "2024-03-04",
            "claude 35 haiku": "2024-10-22",
            "claude 35 sonnet new": "2024-10-22",
            "claude 36 sonnet": "2024-10-22",
            "claude 35 sonnet": "2024-06-20",
            "claude 37": "2025-02-24",
            "claude 37 sonnet": "2025-02-24",
            "claude 4 sonnet": "2025-05-22",
            "claude 4 opus": "2025-05-22",
            "codestral 2501": "2025-01-13",
            "command a": "2025-03-13",
            "command r": "2024-03-11",
            "command r+": "2024-08-30",
            "dbrx": "2024-03-27",
            "deepseek r1": "2025-01-20",
            "deepseek r1 0528": "2025-05-28",
            "deepseek v2": "2024-05-06",
            "deepseek v 25": "2024-09-05",
            "deepseek v3": "2024-12-26",
            "falcon 7b": "2023-05-25",
            "falcon 40 b": "2023-03-17",
            "falcon 180 b": "2023-09-06",
            "flan t5 base": "2022-10-20",
            "flan t5 large": "2022-10-20",
            "flan t5 small": "2022-10-20",
            "flan t5 xl": "2022-10-20",
            "flan t5 xxl": "2022-10-20",
            "gemini exp 1206": "2024-12-17",
            "gemini 15": "2024-02-15",
            "gemini 15 pro 002": "2024-09-24",
            "gemini 15 flash 002": "2024-09-24",
            "gemini ultra": "2024-02-08",
            "gemini 20 flash": "2024-12-11",
            "gemini 20 flash lite": "2025-02-05",
            "gemini 20 flash thinking exp 01 21": "2025-01-21",
            "gemini 20 pro": "2025-02-05",
            "gemini 25 flash": "2025-04-17",
            "gemini 25 flash preview 05 20": "2025-05-20",
            "gemini 25 pro": "2025-03-25",
            "gemini 25 pro 06 05": "2025-06-05",
            "gemma": "2024-02-21",
            "gemma 2": "2024-06-27",
            "gemma 3": "2025-03-10",
            "gpt 2": "2019-02-14",
            "gpt 2 15 b": "2019-11-05",
            "gpt 3": "2020-06-11",
            "gpt 3 davinci 175 b": "2020-06-11",
            "gpt 35": "2022-03-15",
            "gpt 35 turbo": "2024-01-25",
            "gpt 4": "2023-03-14",
            "gpt 4 turbo": "2024-04-09",
            "gpt 41": "2025-04-14",
            "gpt 45": "2025-02-27",
            "gpt 4o mini": "2024-07-18",
            "gpt 4o": "2024-05-13",
            "gpt neox 20 b": "2022-04-07",
            "grok 1": "2023-11-04",
            "grok 2": "2024-08-13",
            "grok 3": "2025-02-17",
            "inflection 25": "2024-03-07",
            "jamba": "2024-03-29",
            "llama nemotron ultra": "2025-04-07",
            "llama": "2023-02-24",
            "llama 2": "2023-07-01",
            "llama 3": "2024-04-18",
            "llama 31": "2024-07-23",
            "llama 32": "2024-09-25",
            "llama 33": "2024-12-06",
            "llama 4": "2025-04-05",
            "llama 4 maverick": "2025-04-05",
            "llama 4 scout": "2025-04-05",
            "llama 4 scout 17 b instruct": "2025-04-05",
            "magistral small 2506": "2025-06-10",
            "minimax text 01": "2025-01-12",
            "ministral 3b 2410": "2024-10-16",
            "ministral 8b 2410": "2024-10-16",
            "mistral": "2023-09-27",
            "mistral 7b": "2023-09-27",
            "mistral large 2 2407": "2024-07-24",
            "mistral large 2411": "2024-11-19",
            "mistral large 2 2411": "2024-11-19",
            "mistral medium 2505": "2025-05-07",
            "mistral medium 3": "2025-05-07",
            "mistral medium 31": "2025-05-07",
            "mistral small": "2024-02-26",
            "mistral small 3": "2025-01-30",
            "mistral small 31": "2025-03-17",
            "mixtral 8 x 7 b": "2023-12-09",
            "mixtral 8 x 22 b": "2024-04-10",
            "nemotron 4": "2024-07-14",
            "nova": "2024-12-03",
            "o1": "2024-09-12",
            "o3": "2025-04-16",
            "o3 mini": "2025-01-31",
            "o3 pro": "2025-06-10",
            "o4 mini": "2025-04-16",
            "opt 175 b": "2022-05-03",
            "opt 66 b": "2022-06-23",
            "palm 2": "2023-05-10",
            "phi 15": "2023-09-10",
            "phi 2": "2023-12-12",
            "phi 3": "2024-04-23",
            "phi 35": "2024-08-22",
            "phi 4": "2024-12-12",
            "pythia": "2023-03-13",
            "qwen 7b": "2023-09-13",
            "qwen 15 72 b": "2024-02-04",
            "qwen 2 7b": "2024-07-23",
            "qwen 2 72 b": "2024-07-23",
            "qwen 2 vl 72 b": "2024-08-29",
            "qwen 25 max": "2025-01-29",
            "qwen 25 coder 32 b instruct": "2024-09-19",
            "qwen 25 72 b": "2024-09-19",
            "qwen 3": "2025-04-29",
            "qwen qwq 32 b": "2025-03-05",
            "qwq 32 b": "2025-03-05",
            "sora": "2024-12-09",
            "stable lm 2": "2024-01-19",
            "xgen 7b": "2023-07-03"
        }

        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const inputContainer = document.getElementById('inputContainer');
            const dataInput = document.getElementById('dataInput');
            const parseButton = document.getElementById('parseButton');
            const clearButton = document.getElementById('clearButton');
            const hideInputButton = document.getElementById('hideInputButton');
            const resetButton = document.getElementById('resetButton');
            const showInputButton = document.getElementById('showInputButton');
            const showInputContainer = document.getElementById('showInputContainer');
            const formatDetectionMessage = document.getElementById('formatDetectionMessage');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const errorMessage = document.getElementById('errorMessage');
            const resultSection = document.getElementById('resultSection');
            const formatInfo = document.getElementById('formatInfo');
            const patternInfo = document.getElementById('patternInfo');
            const tableStructure = document.getElementById('tableStructure');
            const tableContainer = document.getElementById('tableContainer');
            const toggleHeadersButton = document.getElementById('toggleHeadersButton');
            const convertToCsvButton = document.getElementById('convertToCsvButton');
            const convertToJsonButton = document.getElementById('convertToJsonButton');
            const drawChartButton = document.getElementById('drawChartButton');
            const exportOutputContainer = document.getElementById('exportOutputContainer');
            const exportFormatLabel = document.getElementById('exportFormatLabel');
            const exportOutput = document.getElementById('exportOutput');
            const copyOutputButton = document.getElementById('copyOutputButton');
            const closeOutputButton = document.getElementById('closeOutputButton');
            const deleteColumnsButton = document.getElementById('deleteColumnsButton');
            const toggleColumnsButton = document.getElementById('toggleColumnsButton');
            const addDateColumnButton = document.getElementById('addDateColumnButton');
            const columnActionContainer = document.getElementById('columnActionContainer');
            const columnSelectionError = document.getElementById('columnSelectionError');
            const chartErrorToast = document.getElementById('chartErrorToast');
            const chartErrorMessage = document.getElementById('chartErrorMessage');
            const chartContainer = document.getElementById('chartContainer');
            const downloadChartButton = document.getElementById('downloadChartButton');
            const hiddenLink = document.getElementById('hiddenLink');
            const closeChartButton = document.getElementById('closeChartButton');
            const chartCanvas = document.getElementById('chartCanvas');
            const frontierControlContainer = document.getElementById('frontierControlContainer');
            const frontierToggleCheckbox = document.getElementById('frontierToggleCheckbox');
            
            const fadeOverlay = document.getElementById('fadeOverlay');
            const toggleButton = document.getElementById('toggleButton');
            const iconDown = document.getElementById('iconDown');
            const iconUp = document.getElementById('iconUp');
            
            // Store the state for header editing
            let editableHeaders = true;
            let currentHeaderSelections = [];
            let lastTableData = null;
            let currentExportFormat = 'CSV';
            let currentDataFormat = 'text';
            let showColumnCheckboxes = false;
            let columnSelectionEnabled = false; // Track if column selection mode is active
            let dateColumnIndex = -1; // Track the index of the date column
            let chartInstance = null; // Track the chart instance
            let showFrontierOnly = true; // Track if frontier mode is active (default to true)
            let fullChartData = null; // Store the full chart data for toggling between all data and frontier only
            
            // Sorting state
            let currentSortColumn = -1; // Track which column is being sorted
            let currentSortDirection = ''; // 'asc' or 'desc'
            
            // Store structured data for CSV/JSON exports
            let structuredData = {
                headers: [],
                rows: []
            };
            
            // Function to parse and sort numeric values
            function parseNumeric(value) {
                if (!value) return null;
                
                // Handle values like "35.5 ± 2.0", extract just the first number
                const numericValue = value.toString().trim();
                const spaceIndex = numericValue.indexOf(' ');
                const cleanValue = spaceIndex > 0 ? numericValue.substring(0, spaceIndex) : numericValue;
                
                // Handle percentage and dollar values
                const withoutUnits = cleanValue.replace('%', '').replace('$', '').trim();
                
                // Parse as float
                const floatValue = parseFloat(withoutUnits);
                
                // The code that calls this function only checks for (strictly) `null` even though parseFloat can return `NaN`
                return (Number.isNaN(floatValue)) ? null : floatValue;
            }
            
            // The button to activate "Select Columns (for deletion)" mode should only be clickable when there are more columns than needed
            // The minimum set of columns for a chart is Date+Value, but Text+Value can be converted to Text+Date+Value by using the Add Date Column button
            // In practice, this means that deleting a column is probably safe if there are 3 or more columns, but not safe if there are only 2 columns left
            function updateSelectColumnsButton() {
                const columnCount = document.querySelectorAll('#tableContainer th').length;
                if (columnCount >= 3) {
                    toggleColumnsButton.disabled = false;
                } else {
                    toggleColumnsButton.disabled = true;
                }
            }
            
            // Function to detect if the column data is sorted
            function detectColumnSortOrder(columnData, columnType) {
                if (columnData.length < 2) return '';
                
                let isAscending = true;
                let isDescending = true;
                
                // Clone the data to avoid modifying the original
                const processedData = [...columnData];
                
                // Sort the values based on column type
                for (let i = 1; i < processedData.length; i++) {
                    let prev, curr;
                    
                    if (columnType === 'N') {
                        // For numeric columns, parse the values
                        prev = parseNumeric(processedData[i-1]);
                        curr = parseNumeric(processedData[i]);
                        
                        // Skip if values can't be parsed
                        if (prev === null || curr === null) continue;
                    } else if (columnType === 'D') {
                        // For date columns, compare as strings (assuming ISO format)
                        prev = processedData[i-1];
                        curr = processedData[i];
                    } else {
                        // For text columns, compare directly
                        prev = processedData[i-1];
                        curr = processedData[i];
                    }
                    
                    // Check if the order is maintained
                    if (prev > curr) isAscending = false;
                    if (prev < curr) isDescending = false;
                    
                    // If neither ascending nor descending, break early
                    if (!isAscending && !isDescending) break;
                }
                
                // Return the detected order
                if (isAscending && !isDescending) return 'asc';
                if (isDescending && !isAscending) return 'desc';
                return ''; // No clear order
            }
            
            // Function to sort the table data by column
            function sortTableByColumn(columnIndex, direction) {
                // Update the current sort state
                currentSortColumn = columnIndex;
                currentSortDirection = direction;
                
                if (currentDataFormat === 'text') {
                    // Text format sorting
                    if (!lastTableData) return;
                    
                    const columnType = lastTableData.pattern[columnIndex];
                    
                    // Sort the data rows
                    lastTableData.dataRows.sort((a, b) => {
                        let valA = a[columnIndex];
                        let valB = b[columnIndex];
                        
                        if (columnType === 'N') {
                            // Parse numeric values
                            valA = parseNumeric(valA);
                            valB = parseNumeric(valB);
                            
                            // Handle null values
                            if (valA === null && valB === null) return 0;
                            if (valA === null) return direction === 'asc' ? -1 : 1;
                            if (valB === null) return direction === 'asc' ? 1 : -1;
                            
                            return direction === 'asc' ? valA - valB : valB - valA;
                        } else if (columnType === 'D') {
                            // For dates, compare as strings (ISO format works for string comparison)
                            return direction === 'asc' ? 
                                valA.localeCompare(valB) : 
                                valB.localeCompare(valA);
                        } else {
                            // Text comparison
                            return direction === 'asc' ? 
                                valA.localeCompare(valB) : 
                                valB.localeCompare(valA);
                        }
                    });
                    
                    // Regenerate the table
                    const tableElement = generateHTMLTable(lastTableData, editableHeaders);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                } else {
                    // Structured data format sorting
                    if (!structuredData || !structuredData.headers || !structuredData.rows) return;
                    
                    // Determine column type by checking first few values
                    let columnType = 'T'; // Default to text
                    const sampleRows = structuredData.rows.slice(0, Math.min(5, structuredData.rows.length));
                    let numericCount = 0;
                    let dateCount = 0;
                    let emptyCount = 0;
                    
                    for (const row of sampleRows) {
                        if (columnIndex < row.length) {
                            const cellType = classifyCell(row[columnIndex]);
                            if (cellType === 'N') numericCount++;
                            if (cellType === 'D') dateCount++;
                            if (cellType === 'E') emptyCount++;
                        }
                    }
                    
                    // Assign type based on majority
                    const majorityThreshold = (sampleRows.length - emptyCount) / 2;
                    if (numericCount > dateCount && numericCount > majorityThreshold) {
                        columnType = 'N';
                    } else if (dateCount > numericCount && dateCount > majorityThreshold) {
                        columnType = 'D';
                    }
                    
                    // Sort the data rows
                    structuredData.rows.sort((a, b) => {
                        let valA = columnIndex < a.length ? a[columnIndex] : '';
                        let valB = columnIndex < b.length ? b[columnIndex] : '';
                        
                        if (columnType === 'N') {
                            // Parse numeric values
                            valA = parseNumeric(valA);
                            valB = parseNumeric(valB);
                            
                            // Handle null values
                            if (valA === null && valB === null) return 0;
                            if (valA === null) return direction === 'asc' ? -1 : 1;
                            if (valB === null) return direction === 'asc' ? 1 : -1;
                            
                            return direction === 'asc' ? valA - valB : valB - valA;
                        } else if (columnType === 'D') {
                            // For dates, compare as strings (ISO format works for string comparison)
                            return direction === 'asc' ? 
                                valA.localeCompare(valB) : 
                                valB.localeCompare(valA);
                        } else {
                            // Text comparison
                            return direction === 'asc' ? 
                                valA.localeCompare(valB) : 
                                valB.localeCompare(valA);
                        }
                    });
                    
                    // Regenerate the table
                    const tableElement = generateStructuredHTMLTable(structuredData);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                }
                
                // If we have date inputs, we need to add them back
                if (!columnSelectionEnabled && dateColumnIndex !== -1) {
                    addDateInputsToEmptyCells();
                }
                
                // If column selection is enabled, set up the checkboxes
                if (columnSelectionEnabled && showColumnCheckboxes) {
                    setupColumnCheckboxes();
                }
            }
            
            // Function to check if data in a column is already sorted
            function checkInitialSortOrder() {
                if (currentDataFormat === 'text') {
                    if (!lastTableData || !lastTableData.dataRows || lastTableData.dataRows.length < 2) return;
                    
                    // Check each column
                    for (let colIndex = 0; colIndex < lastTableData.pattern.length; colIndex++) {
                        const columnType = lastTableData.pattern[colIndex];
                        
                        // Extract column data
                        const columnData = lastTableData.dataRows.map(row => row[colIndex]);
                        
                        // Detect sort order
                        const sortOrder = detectColumnSortOrder(columnData, columnType);
                        
                        if (sortOrder) {
                            // If sorted, set the sort indicators
                            currentSortColumn = colIndex;
                            currentSortDirection = sortOrder;
                            
                            // Update header UI
                            const headers = document.querySelectorAll('table th');
                            if (colIndex < headers.length) {
                                headers[colIndex].classList.add(`sort-${sortOrder}`);
                            }
                            
                            // Only mark the first sorted column
                            break;
                        }
                    }
                } else {
                    if (!structuredData || !structuredData.rows || structuredData.rows.length < 2) return;
                    
                    // Check each column
                    for (let colIndex = 0; colIndex < structuredData.headers.length; colIndex++) {
                        // Determine column type
                        let columnType = 'T'; // Default to text
                        const sampleRows = structuredData.rows.slice(0, Math.min(5, structuredData.rows.length));
                        let numericCount = 0;
                        let dateCount = 0;
                        
                        for (const row of sampleRows) {
                            if (colIndex < row.length) {
                                const cellType = classifyCell(row[colIndex]);
                                if (cellType === 'N') numericCount++;
                                if (cellType === 'D') dateCount++;
                            }
                        }
                        
                        // Assign type based on majority
                        if (numericCount > dateCount && numericCount > sampleRows.length / 2) {
                            columnType = 'N';
                        } else if (dateCount > numericCount && dateCount > sampleRows.length / 2) {
                            columnType = 'D';
                        }
                        
                        // Extract column data
                        const columnData = structuredData.rows.map(row => 
                            colIndex < row.length ? row[colIndex] : ''
                        );
                        
                        // Detect sort order
                        const sortOrder = detectColumnSortOrder(columnData, columnType);
                        
                        if (sortOrder) {
                            // If sorted, set the sort indicators
                            currentSortColumn = colIndex;
                            currentSortDirection = sortOrder;
                            
                            // Update header UI
                            const headers = document.querySelectorAll('table th');
                            if (colIndex < headers.length) {
                                headers[colIndex].classList.add(`sort-${sortOrder}`);
                            }
                            
                            // Only mark the first sorted column
                            break;
                        }
                    }
                }
            }
            
            // Modified generateHTMLTable function to add sorting functionality
            function generateHTMLTable(tableData, editable = true) {
                const { columnsPerRow, headers: originalHeaders, dataRows, pattern } = tableData;
                
                // The list of headers might need to be fixed later, so the above line created a temporary const called originalHeaders
                let headers = originalHeaders;
                
                // Create table element
                const table = document.createElement('table');
                // Only add sortable class if headers are not editable (i.e. there are no dropdown lists)
                table.className = 'min-w-full border-collapse border-spacing-0' + (!editable ? ' sortable' : '');
                
                // Create header section
                const thead = document.createElement('thead');
                
                // Check if we should show checkboxes (3+ columns)
                // (Update the global variable)
                showColumnCheckboxes = shouldShowColumnCheckboxes(pattern.length);
                
                const showAddDateColumnsButton = !checkContainsDateFormatCell(dataRows);
                
                // Show the column action container if needed
                if (showColumnCheckboxes || showAddDateColumnsButton) {
                    columnActionContainer.classList.remove('hidden');
                } else {
                    columnActionContainer.classList.add('hidden');
                }
                
                // Add checkbox row if needed (when both allowed and enabled)
                if (showColumnCheckboxes && columnSelectionEnabled) {
                    const checkboxRow = document.createElement('tr');
                    for (let j = 0; j < columnsPerRow; j++) {
                        const th = document.createElement('th');
                        th.className = 'px-4 py-2 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 text-center';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'w-4 h-4 column-checkbox';
                        checkbox.id = `column-checkbox-${j}`;
                        checkbox.dataset.columnIndex = j.toString();
                        
                        th.appendChild(checkbox);
                        checkboxRow.appendChild(th);
                    }
                    thead.appendChild(checkboxRow);
                }
                
                // Add header row
                const headerRow = document.createElement('tr');
                
                // Special case for if only one header value is available
                const validHeaders = headers.filter(truthy => truthy);
                if (validHeaders.length < 2) {
                    // The headers might all be on one row, separated by tabs
                    if (validHeaders[0] && validHeaders[0].includes('\t')) {
                        headers = validHeaders[0].split('\t');
                        tableData.headers = headers;
                    } else {
                        // No point in having a dropdown list
                        editable = false;
                    }
                }
                
                // Initialize or use the current selections
                if (currentHeaderSelections.length === 0 || currentHeaderSelections.length !== columnsPerRow) {
                    // Initialize with intelligent defaults
                    currentHeaderSelections = selectDefaultHeaders(tableData);
                }
                
                // Create header cells for each column
                for (let j = 0; j < columnsPerRow; j++) {
                    const th = document.createElement('th');
                    th.className = 'px-4 py-2 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-700';
                    
                    // Add sorting class if this is the currently sorted column and sorting is enabled
                    if (j === currentSortColumn && !editable) {
                        th.classList.add(`sort-${currentSortDirection}`);
                    }
                    
                    // Only add click event for sorting if it's enabled
                    if (!editable) {
                        th.addEventListener('click', () => {
                            // If this is already the sort column, toggle direction
                            if (j === currentSortColumn) {
                                const newDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                                sortTableByColumn(j, newDirection);
                            } else {
                                // Otherwise, sort ascending by default
                                sortTableByColumn(j, 'asc');
                            }
                        });
                    }
                    
                    // Check if this is "Release Date" and update the date column index
                    if (currentHeaderSelections[j] === "Release Date") {
                        dateColumnIndex = j;
                        // Make sure the list of headers also has that option in it
                        if (!headers.includes("Release Date")) {
                            headers.push("Release Date");
                        }
                    }
                    
                    if (editable) {
                        // Create a dropdown for the header
                        const select = document.createElement('select');
                        select.id = `header-select-${j}`;
                        select.className = 'w-full bg-transparent dark:bg-gray-800 border-none focus:ring-2 focus:ring-primary';
                        select.dataset.column = j.toString();
                        
                        // Add options for each possible header
                        headers.forEach(header => {
                            const option = document.createElement('option');
                            option.value = header;
                            option.textContent = header;
                            if (currentHeaderSelections[j] === header) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });
                        
                        // Add event listener for change
                        select.addEventListener('change', function() {
                            const columnIndex = parseInt(this.dataset.column);
                            const previousHeader = currentHeaderSelections[columnIndex];
                            currentHeaderSelections[columnIndex] = this.value;
                            
                            // Update dateColumnIndex if applicable
                            if (previousHeader === "Release Date") {
                                // Previous header was "Release Date", clear the date column index if no other is found
                                dateColumnIndex = currentHeaderSelections.indexOf("Release Date");
                                if (dateColumnIndex === -1) {
                                    checkForDateColumn(); // Check if we need to show the Add Date Column button
                                }
                            } else if (this.value === "Release Date") {
                                // New header is "Release Date", update the date column index
                                dateColumnIndex = columnIndex;
                            }
                        });
                        
                        th.appendChild(select);
                    } else {
                        // Just show the static header text
                        th.appendChild(document.createTextNode(currentHeaderSelections[j]));
                    }
                    
                    headerRow.appendChild(th);
                }
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                // Add data rows
                dataRows.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    tr.className = rowIndex % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800';
                    
                    // Add cells to the row
                    row.forEach((cellValue, cellIndex) => {
                        const td = document.createElement('td');
                        const cellType = classifyCell(cellValue);
                        
                        let cellClass = 'px-4 py-2 border border-gray-300 dark:border-gray-700';
                        
                        // Add classes based on cell type
                        if (cellType === 'N') {
                            cellClass += ' text-right font-mono';
                        } else if (cellType === 'D') {
                            cellClass += ' text-center whitespace-nowrap';
                        }
                        
                        td.className = cellClass;
                        
                        // Check if this is a date column with an empty cell (needs input field)
                        if (cellIndex === dateColumnIndex && !columnSelectionEnabled && cellValue === '') {
                            const input = createDateInput('');
                            
                            // Add event to save the value to the data structure
                            input.addEventListener('change', function() {
                                const formattedDate = parseAndFormatDate(this.value);
                                this.value = formattedDate; // Update input with formatted date
                                
                                // Update the data structure
                                dataRows[rowIndex][cellIndex] = formattedDate;
                            });
                            
                            td.appendChild(input);
                        } else {
                            td.appendChild(document.createTextNode(cellValue));
                        }
                        
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                
                return table;
            }

            // Modified generateStructuredHTMLTable function to add sorting functionality
            function generateStructuredHTMLTable(data) {
                const { headers, rows } = data;
                
                // Create table element
                const table = document.createElement('table');
                // Set the default classes
                table.className = 'min-w-full border-collapse border-spacing-0 sortable';
                
                // Create header
                const thead = document.createElement('thead');
                
                // Check if we should show checkboxes (3+ columns)
                // (Update the global variable)
                showColumnCheckboxes = shouldShowColumnCheckboxes(headers.length);
                
                const showAddDateColumnsButton = !checkContainsDateFormatCell(rows);
                
                // Show the column action container if needed
                if (showColumnCheckboxes || showAddDateColumnsButton) {
                    columnActionContainer.classList.remove('hidden');
                } else {
                    columnActionContainer.classList.add('hidden');
                }
                
                // Add checkbox row if needed (when both allowed and enabled)
                if (showColumnCheckboxes && columnSelectionEnabled) {
                    const checkboxRow = document.createElement('tr');
                    headers.forEach((header, index) => {
                        const th = document.createElement('th');
                        th.className = 'px-4 py-2 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 text-center';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'w-4 h-4 column-checkbox';
                        checkbox.id = `column-checkbox-${index}`;
                        checkbox.dataset.columnIndex = index.toString();
                        
                        th.appendChild(checkbox);
                        checkboxRow.appendChild(th);
                    });
                    thead.appendChild(checkboxRow);
                }
                
                // Add header row
                const headerRow = document.createElement('tr');
                headers.forEach((header, index) => {
                    const th = document.createElement('th');
                    th.className = 'px-4 py-2 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 text-left';
                    th.appendChild(document.createTextNode(header));
                    
                    // Add sorting class if this is the currently sorted column
                    if (index === currentSortColumn) {
                        th.classList.add(`sort-${currentSortDirection}`);
                    }
                    
                    // Add click event for sorting
                    th.addEventListener('click', () => {
                        // If this is already the sort column, toggle direction
                        if (index === currentSortColumn) {
                            const newDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                            sortTableByColumn(index, newDirection);
                        } else {
                            // Otherwise, sort ascending by default
                            sortTableByColumn(index, 'asc');
                        }
                    });
                    
                    // Track the date column index if this is a "Release Date" column
                    if (header === "Release Date") {
                        dateColumnIndex = index;
                    }
                    
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                // Add data rows
                rows.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    tr.className = rowIndex % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800';
                    
                    // Fill in cells, handling the case where a row might have fewer cells than headers
                    for (let i = 0; i < headers.length; i++) {
                        const cellValue = i < row.length ? row[i] : '';
                        const cellType = classifyCell(cellValue);
                        
                        const td = document.createElement('td');
                        let cellClass = 'px-4 py-2 border border-gray-300 dark:border-gray-700';
                        
                        // Add classes based on cell type
                        if (cellType === 'N') {
                            cellClass += ' text-right font-mono';
                        } else if (cellType === 'D') {
                            cellClass += ' text-center whitespace-nowrap';
                        }
                        
                        td.className = cellClass;
                        
                        // Check if this is a date column with an empty cell (needs input field)
                        if (i === dateColumnIndex && !columnSelectionEnabled && cellValue === '') {
                            const input = createDateInput('');
                            
                            // Add event to save the value to the data structure
                            input.addEventListener('change', function() {
                                const formattedDate = parseAndFormatDate(this.value);
                                this.value = formattedDate; // Update input with formatted date
                                
                                // Update the data structure
                                rows[rowIndex][i] = formattedDate;
                            });
                            
                            td.appendChild(input);
                        } else {
                            td.appendChild(document.createTextNode(cellValue));
                        }
                        
                        tr.appendChild(td);
                    }
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                
                return table;
            }

            // Event handlers
            hideInputButton.addEventListener('click', () => {
                inputContainer.classList.add('hidden');
                showInputContainer.classList.remove('hidden');
            });
            showInputButton.addEventListener('click', () => {
                inputContainer.classList.remove('hidden');
                showInputContainer.classList.add('hidden');
                hideInputButton.classList.remove('hidden');
            });

            resetButton.addEventListener('click', () => {
                inputContainer.classList.remove('hidden');
                showInputContainer.classList.add('hidden');
                hideInputButton.classList.add('hidden');
                // Only set the focus after the element to be focused is visible
                clearData();
            });

            document.getElementById('item0').addEventListener('click', () => {
                inputContainer.classList.remove('hidden');
                showInputContainer.classList.add('hidden');
                hideInputButton.classList.add('hidden');
                // Only set the focus after the element to be focused is visible
                clearData();
            });
            
            // Each of the menu items (benchmarks) in the aside should trigger the textarea to be filled, the table to be created, and the chart to be drawn
            document.querySelectorAll('aside ul label').forEach(benchmark => benchmark.addEventListener('click', () => {
                // Extract the value of the "for" attribute
                const forValue = benchmark.getAttribute('for');
                
                // Set the page fragment to the value of the "for" attribute
                if (forValue) {
                    window.location.hash = forValue;
                }
                
                const hiddenTextarea = benchmark.querySelector('textarea');
                if (hiddenTextarea) {
                    dataInput.value = hiddenTextarea.value;
                    
                    // Create a MutationObserver to watch for changes to an element in the page
                    // This is a lot of code written to ensure a simple constraint, namely that the table of data exists before the chart is rendered
                    const observer = new MutationObserver((mutationsList, observer) => {
                        for (const mutation of mutationsList) {
                            if (mutation.type === 'childList' || mutation.type === 'subtree') {
                                // Check if the specific element has the expected content
                                if (document.getElementById('tableContainer')) {
                                    // Check for initial sort order
                                    setTimeout(checkInitialSortOrder, 0);
                                    
                                    prepareChartData(); // Only trigger the charting process once the table of data exists
                                    observer.disconnect(); // Stop observing after the first call
                                    break; // Exit the loop
                                }
                            }
                        }
                    });
                    // Start observing the target node for the relevant mutations
                    const targetNode = document.getElementById('truncatedTableContainer');
                    observer.observe(targetNode, { childList: true, subtree: true });
                    
                    // Paradoxically, we want the parseData() step to happen before prepareChartData(), but parseData() is mentioned last
                    // That's because the reference to prepareChartData() occurs as the payload to an observer which has to be in place before parseData() is triggered
                    parseData();
                    
                    // For consistency, make the table drawer start closed
                    openCloseDrawer('close');
                } else {
                    console.log('No <textarea> found for benchmark');
                }
            }));

            // Check whether the page already has a fragment set, and activate the event handler as if the user had clicked the respective menu item
            const currentFragment = window.location.hash;
            if (currentFragment) {
                const inputElement = document.querySelector(currentFragment);
                if (inputElement) {
                    const justTheInputId = currentFragment.substr(1);
                    const theLabel = document.querySelector(`label[for="${justTheInputId}"]`);
                    theLabel.click();
                }
            }
            
            // Helper function for opening or closing the "drawer" UI element that hides the initial data table
            function openCloseDrawer(action = 'open') {
                if (action == 'open') {
                    // Expand the table
                    tableContainer.classList.add('is-expanded');
                    // Hide the fade overlay
                    fadeOverlay.classList.add('hidden');
                    // Show the 'Up' arrow, hide the 'Down' arrow
                    iconDown.classList.add('hidden');
                    iconUp.classList.remove('hidden');
                    // Update ARIA attributes
                    toggleButton.setAttribute('aria-expanded', 'true');
                    toggleButton.setAttribute('aria-label', 'Show fewer rows');
                } else {
                    // Collapse the table
                    tableContainer.classList.remove('is-expanded');
                    // Show the fade overlay
                    fadeOverlay.classList.remove('hidden');
                    // Show the 'Down' arrow, hide the 'Up' arrow
                    iconDown.classList.remove('hidden');
                    iconUp.classList.add('hidden');
                    // Update ARIA attributes
                    toggleButton.setAttribute('aria-expanded', 'false');
                    toggleButton.setAttribute('aria-label', 'Show more rows');
                }
            }
            
            toggleButton.addEventListener('click', () => {
                // Check if the table is currently collapsed (by checking class)
                const isCollapsed = !tableContainer.classList.contains('is-expanded');
                const action = isCollapsed ? 'open' : 'close';
                openCloseDrawer(action);
            });

            addDateColumnButton.addEventListener('click', addDateColumn);
            drawChartButton.addEventListener('click', prepareChartData);
            closeChartButton.addEventListener('click', () => {
                chartContainer.classList.add('hidden');
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
            });
            
            // Add event listener for the frontier toggle checkbox
            frontierToggleCheckbox.addEventListener('change', function() {
                showFrontierOnly = this.checked;
                
                // If we have full chart data, redraw the chart with the current mode
                if (fullChartData) {
                    createChartWithData(fullChartData);
                }
            });
            
            downloadChartButton.addEventListener('click', () => {
                // Update the hidden anchor containing the image data
                hiddenLink.href = chartInstance.toBase64Image();
                hiddenLink.click()
            });
            
            // Function to show a temporary error toast
            function showToast(message, duration = 3000) {
                chartErrorMessage.textContent = message;
                chartErrorToast.classList.add('show');
                
                setTimeout(() => {
                    chartErrorToast.classList.remove('show');
                }, duration);
            }
            
            // Utility function to normalize a mode name (lowercase and trim)
            function normalize(str) {
                return str.toLowerCase().trim();
            }

            // Tokenizer function: splits a model name string into components of letters and numbers.
            //   It splits something like "claude35" into ["claude", "35"]
            //   but leaves "o4" as one token if you detect that it should be (here we assume if the token is 2 characters, we leave it).
            function tokenize(str) {
                // Normalize
                const normalized = normalize(str);
                
                // Special case for strings like "claude-3-5-2024-10-23", to group single digits together (this won't work if there is a model version 10.1)
                // (?<=\b\d\b) is a positive lookbehind that asserts that before the dash there is a single digit (with word boundaries ensuring it's not part of a longer number)
                const groupedSingleDigits = normalized.replace(/(?<=\b\d\b)-(?=\b\d\b)/g, '');
                
                // Version numbers like 3.5.1 mustn't be split or they create effectively an unordered set {3, 5, 1}
                // Concatenating them into 351 shouldn't cause a false positive
                // Also it is unlikely there will be any models whose names contain tokens that are ambiguous when dots are removed, like "GP.t"
                const dotless = groupedSingleDigits.replace('.', '');
                
                // Remove extra punctuation that we assume shouldn't affect tokenization.
                // For example, remove commas, hyphens, parentheses, and slashes.
                // Don't remove plus signs, though, because of course "Command R+" had to be a thing.
                const noPunct = dotless.replace(/[,()\-*/\\]/g, ' ');
                
                // Split by whitespace
                let tokens = noPunct.split(/\s+/).filter(Boolean);
                
                // For each token, check if it can be further split if it contains both letters and numbers.
                // We check tokens longer than 2 characters to consider splitting.
                const refined = [];
                
                tokens.forEach(token => {
                    // Only attempt splitting if there is both a letter and a number.
                    if (token.length > 2 && /[a-z]/.test(token) && /[0-9]/.test(token)) {
                        // We use a regex to separate alphabetic parts and numeric parts.
                        // For example, "claude35" → ["claude", "35"]
                        const parts = token.match(/[a-z]+|[0-9]+/g);
                        if (parts && parts.join('') === token) {
                            refined.push(...parts);
                        } else {
                            refined.push(token);
                        }
                    } else {
                        refined.push(token);
                    }
                });
                return refined;
            }
            
            // Require that all the candidate tokens (for a canonical name) are in an array of user specified tokens
            // Both "o3" and "o3-mini" (as canonical names) might match "o3-mini (2025-02-06)" but we take the highest scoring candidate
            function inclusiveMatchScore(userTokens, candidateTokens) {
                let score = 0;
                for (const token of candidateTokens) {
                    if (userTokens.includes(token)) {
                        score++;
                    } else {
                        // A candidate must score zero if one of its tokens isn't present in the user's input
                        return 0;
                    }
                }
                return score;
            }
            
            // Canonicalize a given model name into the format that should allow it to match a key in modelDates
            function canonicalize(userInput) {
                // Tokenize the user input.
                const userTokens = tokenize(userInput);
                // To hold the best candidate info.
                let bestCandidate = null;
                let bestScore = -1;
                
                // Iterate over canonical models and compute match score.
                canonicalModels.forEach(candidate => {
                    const candidateScore = inclusiveMatchScore(userTokens, candidate.tokens);
                    // For debugging, you might want to see:
                    // console.log(`Matching ${userInput} to ${candidate.canonical} [${candidate.tokens.join(", ")}] score=${candidateScore}`);
                    if (candidateScore > bestScore) {
                        bestCandidate = candidate;
                        bestScore = candidateScore;
                    }
                });
                if (bestScore === 0) return null;
                
                // Return the canonical name (or null if no match; in our approach, bestScore may be zero).
                return bestCandidate ? bestCandidate.canonical : null;
            }
            
            // Preprocess the canonical models to compute tokens for each
            // Build an array of objects like { canonical: "o1-preview", tokens: ["o1", "preview"] }
            const canonicalModels = Object.keys(modelDates).map(model => {
                return {
                    canonical: model,
                    tokens: tokenize(model)
                };
            });
            
            // Helper function to convert a date string to days since 1900-01-01 (Excel epoch)
            function dateStringToDays(dateStr) {
                if (!dateStr || dateStr.trim() === '') return null;
                
                try {
                    // Parse the date string
                    const date = new Date(dateStr);
                    
                    // Check if the date is valid
                    if (isNaN(date.getTime())) return null;
                    
                    // Excel epoch is 1900-01-01
                    const excelEpoch = new Date(1900, 0, 1);
                    
                    // Calculate the difference in milliseconds
                    const diffMs = date.getTime() - excelEpoch.getTime();
                    
                    // Convert to days (86400000 ms in a day)
                    const diffDays = Math.floor(diffMs / 86400000);
                    
                    return diffDays;
                } catch (e) {
                    console.error("Error converting date to days:", e);
                    return null;
                }
            }
            
            // Function to format dates for display in chart tooltips
            function formatDateForDisplay(dateStr) {
                if (!dateStr) return '';
                
                try {
                    const date = new Date(dateStr);
                    if (isNaN(date.getTime())) return dateStr;
                    
                    // Format as YYYY-MM-DD
                    return date.toISOString().split('T')[0];
                } catch (e) {
                    return dateStr;
                }
            }
            
            // Function to check if data is already monotonically increasing
            function isDataMonotonicallyIncreasing(points) {
                // Sort points by x value (date) ascending
                const sortedPoints = [...points].sort((a, b) => a.x - b.x);
                
                // Check if y values are monotonically increasing
                let prevY = -Infinity;
                for (const point of sortedPoints) {
                    if (point.y < prevY) {
                        return false;
                    }
                    prevY = point.y;
                }
                return true;
            }
            
            // Function to filter data points to show only the frontier (rising maximum)
            function filterFrontierPoints(points, originalDates, labels) {
                // First sort points by x value (date) ascending
                const sortedIndices = Array.from(Array(points.length).keys())
                    .sort((a, b) => points[a].x - points[b].x);
                
                // Track the highest y value seen
                let highestY = -Infinity;
                let previousIndex = null;
                const frontierIndices = [];
                
                // Find the frontier points
                for (const index of sortedIndices) {
                    if (points[index].y > highestY) {
                        highestY = points[index].y;
                        // Check whether this date is the same as the previous date
                        // If it's a new date, then it's safe to just push the index to the list of frontierIndices, but if not, the previous point needs to be removed first
                        if (previousIndex != null && points[index].x == points[previousIndex].x) {
                            frontierIndices.pop();
                        }
                        frontierIndices.push(index);
                    }
                    previousIndex = index;
                }
                
                // Create filtered arrays
                const filteredPoints = frontierIndices.map(i => points[i]);
                const filteredDates = frontierIndices.map(i => originalDates[i]);
                const filteredLabels = frontierIndices.map(i => labels[i]);
                
                return {
                    points: filteredPoints,
                    originalDates: filteredDates,
                    labels: filteredLabels
                };
            }
            
            // Function to create a chart with the provided data, applying frontier filtering if needed
            function createChartWithData(chartData) {
                // Check if the data is monotonically increasing (already just improvements)
                const isMonotonic = isDataMonotonicallyIncreasing(chartData.points);
                
                // Show/hide the frontier control based on whether it's needed
                if (isMonotonic) {
                    frontierControlContainer.classList.add('hidden');
                    showFrontierOnly = false; // Don't filter if already monotonic
                } else {
                    frontierControlContainer.classList.remove('hidden');
                    // Keep the current state of the checkbox
                }
                
                let dataToUse = chartData;
                
                // If frontier mode is active and data is not monotonic, filter the data
                if (showFrontierOnly && !isMonotonic) {
                    const filtered = filterFrontierPoints(
                        chartData.points, 
                        chartData.originalDates, 
                        chartData.labels
                    );
                    
                    // Create a new data object with filtered points but keeping other properties
                    dataToUse = {
                        ...chartData,
                        points: filtered.points,
                        originalDates: filtered.originalDates,
                        labels: filtered.labels
                    };
                }
                
                // Create the chart with the appropriate data
                createChart(dataToUse);
            }
            
            // Function to calculate linear regression
            function calculateLinearRegression(points) {
                // y = mx + b
                let sumX = 0;
                let sumY = 0;
                let sumXY = 0;
                let sumXX = 0;
                let n = 0;
                
                // Skip points with undefined x or y values
                for (const point of points) {
                    if (point.x !== undefined && point.y !== undefined && 
                        !isNaN(point.x) && !isNaN(point.y)) {
                        sumX += point.x;
                        sumY += point.y;
                        sumXY += point.x * point.y;
                        sumXX += point.x * point.x;
                        n++;
                    }
                }
                
                if (n < 2) {
                    return null; // Need at least 2 points for a line
                }
                
                // Calculate slope (m) and y-intercept (b)
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return {
                    slope: slope,
                    intercept: intercept,
                    formula: `y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}`,
                    // Function to calculate y value for any x
                    calculate: (x) => slope * x + intercept
                };
            }
            
            // Function to convert days since Excel epoch to a formatted date string
            function formatDateFromDays(days) {
                const date = new Date(1900, 0, 1);
                date.setDate(date.getDate() + Math.round(days));
                return date.toISOString().split('T')[0];
            }
            
            // Function to create a chart from the data
            function createChart(chartData) {
                // Destroy any existing chart
                if (chartInstance) {
                    chartInstance.destroy();
                }
                
                // Get the chart context
                const ctx = chartCanvas.getContext('2d');
                
                // Get the current theme (dark or light)
                const isDarkMode = document.documentElement.classList.contains('dark');
                
                // Set colors based on theme
                const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                const textColor = isDarkMode ? '#d1d5db' : '#4b5563';
                
                // Calculate linear regression
                const regression = calculateLinearRegression(chartData.points);
                
                // Prepare datasets
                const datasets = [{
                    label: chartData.valueLabel,
                    data: chartData.points,
                    borderColor: '#5D5CDE',
                    backgroundColor: 'rgba(93, 92, 222, 0.1)',
                    borderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#5D5CDE',
                    tension: 0.1,
                    // The inbuilt support for trend lines doesn't handle extrapolation very well
                    // Instead a custom solution is used, so this config section is marked as "Legacy"
                    trendlineLinearLegacy: {
                        style: "rgba(43, 66, 255, 0.3)",
                        lineStyle: "solid",
                        width: 2,
                        projection: true
                    }
                }];
                
                // Check if we need to add extended trendline points (for percentage data)
                if (regression && chartData.points.every(point => point.y >= 0 && point.y <= 100)) {
                    // Calculate where the line intersects y=0 and y=100
                    const x0 = -regression.intercept / regression.slope;
                    const x100 = (100 - regression.intercept) / regression.slope;
                    
                    // Add extended trendline dataset
                    datasets.push({
                        label: 'Extended Trendline',
                        data: [
                            {x: x0, y: 0},
                            {x: x100, y: 100}
                        ],
                        borderColor: 'rgba(43, 66, 255, 0.3)',
                        borderWidth: 2,
                        pointRadius: 0,
                        showLine: true,
                        fill: false
                    });
                }
                
                // Create new chart
                chartInstance = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const item = tooltipItems[0];
                                        const datasetIndex = item.datasetIndex;
                                        const dataIndex = item.dataIndex;
                                        
                                        // For the main dataset, use original dates
                                        if (datasetIndex === 0 && chartData.originalDates[dataIndex]) {
                                            return chartData.originalDates[dataIndex];
                                        }
                                        
                                        // For extended trendline points, format from days
                                        const point = datasets[datasetIndex].data[dataIndex];
                                        return formatDateFromDays(point.x);
                                    },
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        const value = context.parsed.y;
                                        label += (typeof value === 'number') ? value.toFixed(2) : value;
                                        
                                        // Add label if available (only for main dataset)
                                        if (context.datasetIndex === 0) {
                                            const modelName = chartData.labels[context.dataIndex];
                                            if (modelName) {
                                                label += ` (${modelName})`;
                                            }
                                        }
                                        
                                        return label;
                                    }
                                }
                            },
                            legend: {
                                display: false,
                                labels: {
                                    color: textColor
                                }
                            },
                            title: {
                                display: true,
                                text: chartData.title + (showFrontierOnly ? ' (Improvements Only)' : ''),
                                color: textColor,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: chartData.dateLabel,
                                    color: textColor
                                },
                                ticks: {
                                    color: textColor,
                                    callback: function(value) {
                                        // Find the nearest date
                                        const closestIndex = chartData.points.findIndex(point => 
                                            Math.abs(point.x - value) < 1
                                        );
                                        
                                        if (closestIndex >= 0) {
                                            return chartData.originalDates[closestIndex];
                                        }
                                        
                                        // Convert back to date for display
                                        const date = new Date(1900, 0, 1);
                                        date.setDate(date.getDate() + value);
                                        return date.toISOString().split('T')[0];
                                    }
                                },
                                grid: {
                                    color: gridColor
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: chartData.valueLabel,
                                    color: textColor
                                },
                                ticks: {
                                    color: textColor
                                },
                                grid: {
                                    color: gridColor
                                }
                            }
                        }
                    }
                });
                
                // Show the chart container
                chartContainer.classList.remove('hidden');
                
                // Display regression formula if available
                if (regression) {
                    // Check if formula container exists, create it if not
                    let formulaContainer = document.getElementById('chartFormulaContainer');
                    if (!formulaContainer) {
                        formulaContainer = document.createElement('div');
                        formulaContainer.id = 'chartFormulaContainer';
                        formulaContainer.className = 'mt-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-lg text-center';
                        chartContainer.appendChild(formulaContainer);
                        
                        const formulaElement = document.createElement('p');
                        formulaElement.id = 'trendlineFormula';
                        formulaElement.className = 'font-mono text-lg';
                        formulaContainer.appendChild(formulaElement);
                        
                        const interceptInfo = document.createElement('p');
                        interceptInfo.id = 'interceptInfo';
                        interceptInfo.className = 'mt-2 text-sm';
                        formulaContainer.appendChild(interceptInfo);
                    } else {
                        formulaContainer.classList.remove('hidden');
                    }
                    
                    // Update formula text
                    const formulaElement = document.getElementById('trendlineFormula');
                    formulaElement.textContent = regression.formula;
                    
                    // Add intercept info if this is percentage data
                    if (chartData.points.every(point => point.y >= 0 && point.y <= 100)) {
                        const interceptInfo = document.getElementById('interceptInfo');
                        const x0 = -regression.intercept / regression.slope;
                        const x100 = (100 - regression.intercept) / regression.slope;
                        
                        interceptInfo.textContent = `Reaches 0% on ${formatDateFromDays(x0)} and 100% on ${formatDateFromDays(x100)}`;
                    }
                }
                
                // Scroll to the chart
                chartContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                return chartInstance;
            }
            
            // Helper function for cleaning multi-line strings
            function cleanMultiLine(string) {
                // If the data comes from a pasted HTML, it may contain lots of unnecessary whitespace, so anything after the first newline should be dropped
                // In the regex, [\s\S]* is a common trick to match any character (since . does not match newline by default)
                return string.trim().replace(/\n[\s\S]*/, '');
            }
            
            // Function to prepare data for charting
            function prepareChartData() {
                // Save any date input values before proceeding
                document.querySelectorAll('.date-input').forEach(input => {
                    const rowElement = input.closest('tr');
                    const cellElement = input.closest('td');
                    const rowIndex = Array.from(rowElement.parentNode.children).indexOf(rowElement);
                    const cellIndex = Array.from(rowElement.children).indexOf(cellElement);
                    
                    // Format and save the value
                    const formattedDate = parseAndFormatDate(input.value);
                    
                    // Update the data structure
                    if (currentDataFormat === 'text') {
                        if (lastTableData.dataRows[rowIndex]) {
                            lastTableData.dataRows[rowIndex][cellIndex] = formattedDate;
                        }
                    } else {
                        if (structuredData.rows[rowIndex]) {
                            structuredData.rows[rowIndex][cellIndex] = formattedDate;
                        }
                    }
                });
                
                let headers = [];
                let dateColumnIdx = -1;
                let numericColumnIdx = -1;
                let labelColumnIdx = -1;
                
                // Get headers based on data format
                if (currentDataFormat === 'text') {
                    if (!lastTableData) {
                        showToast("No data available for charting");
                        return;
                    }
                    headers = [...currentHeaderSelections];
                    
                    // Find required columns
                    // 1. Date column - use the tracked dateColumnIndex if available
                    if (dateColumnIndex !== -1) {
                        dateColumnIdx = dateColumnIndex;
                    } else {
                        // Find the first column with date pattern
                        dateColumnIdx = lastTableData.pattern.indexOf('D');
                    }
                    
                    // 2. Numeric column -
                    //   a. find the first column with numeric data in the range 0 - 100 (inclusive)
                    let columns = Array.from({ length: lastTableData.columnsPerRow }, () => new Array());
                    // Don't try using .fill() since it just creates multiple references that all point to the same underlying Array object
                    for (let i=0; i < lastTableData.columnsPerRow; i++) {
                        lastTableData.dataRows.forEach(row => columns[i].push(row[i]));
                    }
                    const numericCounts = columns.map(column => column.filter(value => parseFloat(value) >= 0 && parseFloat(value) <= 100).length);
                    const mostNumericColumnIdx = numericCounts.indexOf(numericCounts.reduce((a,b) => Math.max(a,b)));
                    //   b. find the first column with numeric pattern
                    if (mostNumericColumnIdx >= 0) {
                        numericColumnIdx = mostNumericColumnIdx;
                    } else {
                        numericColumnIdx = lastTableData.pattern.indexOf('N');
                    }
                    
                    // 3. Text label column (optional) - find the first text column that's not used for something else
                    for (let i = 0; i < lastTableData.pattern.length; i++) {
                        if (lastTableData.pattern[i] === 'T' && i !== dateColumnIdx && i !== numericColumnIdx) {
                            labelColumnIdx = i;
                            break;
                        }
                    }
                } else {
                    // For structured data formats
                    if (!structuredData || !structuredData.headers || !structuredData.rows.length === 0) {
                        showToast("No data available for charting");
                        return;
                    }
                    
                    headers = [...structuredData.headers];
                    
                    // 1. Find date column
                    dateColumnIdx = structuredData.headers.findIndex(header => 
                        header.toLowerCase().includes('date') || header === "Release Date"
                    );
                    
                    // If no date column by name, look for columns that contain dates
                    if (dateColumnIdx === -1) {
                        // Sample the first few rows to find date values
                        const sampleRows = structuredData.rows.slice(0, Math.min(5, structuredData.rows.length));
                        
                        for (let col = 0; col < structuredData.headers.length; col++) {
                            let isDateColumn = false;
                            for (let rowIndex = 0; rowIndex < sampleRows.length; rowIndex++) {
                                if (col < sampleRows[rowIndex].length && 
                                    classifyCell(sampleRows[rowIndex][col]) === 'D') {
                                    isDateColumn = true;
                                    break;
                                }
                            }
                            if (isDateColumn) {
                                dateColumnIdx = col;
                                break;
                            }
                        }
                    }
                    
                    // 2. Find numeric column
                    const numericKeywords = ['value', 'score', 'percent', '%', 'number', 'amount', 'rate', 'price'];
                    
                    // First try to find by header name
                    numericColumnIdx = structuredData.headers.findIndex(header => {
                        const headerLower = header.toLowerCase();
                        return numericKeywords.some(keyword => headerLower.includes(keyword));
                    });
                    
                    // If that fails, check column contents
                    if (numericColumnIdx === -1) {
                        // Sample rows to find numeric values
                        const sampleRows = structuredData.rows.slice(0, Math.min(5, structuredData.rows.length));
                        
                        for (let col = 0; col < structuredData.headers.length; col++) {
                            if (col === dateColumnIdx) continue; // Skip date column
                            
                            let numericCount = 0;
                            for (let rowIndex = 0; rowIndex < sampleRows.length; rowIndex++) {
                                if (col < sampleRows[rowIndex].length && 
                                    classifyCell(sampleRows[rowIndex][col]) === 'N') {
                                    numericCount++;
                                }
                            }
                            
                            // If most values are numeric, consider it a numeric column
                            if (numericCount > sampleRows.length / 2) {
                                numericColumnIdx = col;
                                break;
                            }
                        }
                    }
                    
                    // 3. Find text label column (optional)
                    const labelKeywords = ['name', 'model', 'label', 'category', 'system', 'type'];
                    
                    // Try to find by header name
                    labelColumnIdx = structuredData.headers.findIndex(header => {
                        const headerLower = header.toLowerCase();
                        return labelKeywords.some(keyword => headerLower.includes(keyword)) && 
                               headerLower.indexOf('date') === -1; // Make sure it's not a date header
                    });
                    
                    // If still not found, pick the first text column that's not used for something else
                    if (labelColumnIdx === -1) {
                        for (let col = 0; col < structuredData.headers.length; col++) {
                            if (col !== dateColumnIdx && col !== numericColumnIdx) {
                                // Check if column contains mostly text
                                const sampleRows = structuredData.rows.slice(0, Math.min(5, structuredData.rows.length));
                                let textCount = 0;
                                
                                for (let rowIndex = 0; rowIndex < sampleRows.length; rowIndex++) {
                                    if (col < sampleRows[rowIndex].length && 
                                        classifyCell(sampleRows[rowIndex][col]) === 'T') {
                                        textCount++;
                                    }
                                }
                                
                                if (textCount > sampleRows.length / 2) {
                                    labelColumnIdx = col;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Check if we found the required columns
                if (dateColumnIdx === -1 || numericColumnIdx === -1) {
                    if (dateColumnIdx === -1 && numericColumnIdx === -1) {
                        showToast("Missing both date and numeric columns required for charting");
                    } else if (dateColumnIdx === -1) {
                        showToast("Missing date column required for charting");
                    } else {
                        showToast("Missing numeric column required for charting");
                    }
                    return;
                }
                
                // Get the column headers/labels for the chart
                const dateLabel = headers[dateColumnIdx] || `Date (Column ${dateColumnIdx + 1})`;
                const valueLabel = headers[numericColumnIdx] || `Value (Column ${numericColumnIdx + 1})`;
                const labelHeader = labelColumnIdx !== -1 ? headers[labelColumnIdx] || `Label (Column ${labelColumnIdx + 1})` : null;
                
                // Assume that the Date column has a sensible header value, and labelHeader never seems to be used
                const cleanValueLabel = cleanMultiLine(valueLabel);
                
                // Get the data rows
                const rows = currentDataFormat === 'text' ? lastTableData.dataRows : structuredData.rows;
                
                // Prepare data points for the chart
                const chartData = {
                    title: `${cleanValueLabel} by ${dateLabel}`,
                    dateLabel: dateLabel,
                    valueLabel: cleanValueLabel,
                    points: [],
                    originalDates: [], // Store original date strings for tooltips
                    labels: [] // Store model names or labels
                };
                
                // Process each row and extract valid data points
                rows.forEach(row => {
                    // Get date and value
                    const rawDateStr = row[dateColumnIdx] || '';
                    const valueStr = row[numericColumnIdx] || '';
                    
                    // The date value might have some invalid (non-ASCII) characters around it
                    const dateStr = rawDateStr.replace(/[^\x00-\x7F]/g, "").trim();
                    
                    // Skip rows with empty values
                    if (!dateStr || !valueStr) return;
                    
                    // Parse value
                    let value = parseFloat(valueStr.replace(/,/g, ''));
                    if (isNaN(value)) return;
                    
                    // Convert date to days since Excel epoch
                    const daysSinceEpoch = dateStringToDays(dateStr);
                    if (daysSinceEpoch === null) return;
                    
                    // Get label if available
                    const label = labelColumnIdx !== -1 && labelColumnIdx < row.length ? row[labelColumnIdx] : '';
                    
                    // Add data point
                    chartData.points.push({
                        x: daysSinceEpoch,
                        y: value
                    });
                    
                    // Store original date and label
                    chartData.originalDates.push(formatDateForDisplay(dateStr));
                    chartData.labels.push(label);
                });
                
                // Check if we have enough data points
                if (chartData.points.length < 2) {
                    showToast("Not enough valid data points for charting (minimum 2 required)");
                    return;
                }
                
                // Store the full chart data for toggling between all data and frontier only
                fullChartData = chartData;
                
                // Create the chart with the current frontier setting
                createChartWithData(chartData);
            }
            
            // Helper function to parse and format a date string
            function parseAndFormatDate(dateStr) {
                if (!dateStr || dateStr.trim() === '') return '';
                
                try {
                    // Try to parse the date
                    const date = new Date(dateStr);
                    
                    // Check if the date is valid
                    if (isNaN(date.getTime())) return dateStr;
                    
                    // Format as YYYY-MM-DD
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    
                    return `${year}-${month}-${day}`;
                } catch (e) {
                    // If any error occurs, return the original string
                    return dateStr;
                }
            }
            
            // Function to create a date input element
            function createDateInput(initialValue) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'date-input w-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded p-1 text-sm';
                input.placeholder = 'YYYY-MM-DD';
                
                // Set initial value if available
                if (initialValue && initialValue.trim() !== '') {
                    input.value = initialValue;
                }
                
                return input;
            }
            
            // Function to add date inputs to empty cells in the date column
            function addDateInputsToEmptyCells() {
                if (dateColumnIndex === -1) return;
                
                // For text data format
                if (currentDataFormat === 'text') {
                    document.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
                        const cells = row.querySelectorAll('td');
                        
                        if (dateColumnIndex < cells.length) {
                            const cell = cells[dateColumnIndex];
                            const currentValue = lastTableData.dataRows[rowIndex][dateColumnIndex];
                            
                            // If the cell is empty, add an input field
                            if (currentValue === '') {
                                cell.textContent = ''; // Clear the cell
                                
                                const input = createDateInput('');
                                
                                // Add event to save the value to the data structure
                                input.addEventListener('change', function() {
                                    const formattedDate = parseAndFormatDate(this.value);
                                    this.value = formattedDate; // Update input with formatted date
                                    
                                    // Update the data structure
                                    lastTableData.dataRows[rowIndex][dateColumnIndex] = formattedDate;
                                });
                                
                                cell.appendChild(input);
                            }
                        }
                    });
                } else {
                    // For structured data formats
                    document.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
                        const cells = row.querySelectorAll('td');
                        
                        if (dateColumnIndex < cells.length) {
                            const cell = cells[dateColumnIndex];
                            const currentValue = structuredData.rows[rowIndex][dateColumnIndex];
                            
                            // If the cell is empty, add an input field
                            if (currentValue === '') {
                                cell.textContent = ''; // Clear the cell
                                
                                const input = createDateInput('');
                                
                                // Add event to save the value to the data structure
                                input.addEventListener('change', function() {
                                    const formattedDate = parseAndFormatDate(this.value);
                                    this.value = formattedDate; // Update input with formatted date
                                    
                                    // Update the data structure
                                    structuredData.rows[rowIndex][dateColumnIndex] = formattedDate;
                                });
                                
                                cell.appendChild(input);
                            }
                        }
                    });
                }
            }
            
            // Helper function for extracting possible dates from strings
            function findDate(inputString) {
                // Regular expression to match dates in YYYYMMDD or YYYY-MM-DD format
                // To prevent false positives, require that the first digits be "20", assuming AGI arrives before 2100
                const datePattern = /\b(20\d{2})(\d{2})(\d{2})\b|\b(20\d{2})-(\d{2})-(\d{2})\b/;
                const match = inputString.match(datePattern);
                
                if (match) {
                    // Check if the match is in YYYYMMDD format
                    if (match[1]) {
                        // Format it to YYYY-MM-DD
                        return `${match[1]}-${match[2]}-${match[3]}`;
                    } else {
                        // Return the match as is (already in YYYY-MM-DD format)
                        return match[0];
                    }
                }
                
                return "";
            }
            
            // Function to add a new column to the HTML table, containing the release dates of the respective models
            function addDateColumn() {
                // Handle different data formats
                if (currentDataFormat === 'text') {
                    if (!lastTableData) return false;
                    
                    // 1. Look at the text columns and find the one with most matches for modelDates keys
                    let bestColumnIndex = -1;
                    let bestMatchCount = 0;
                    
                    // Loop through columns to find text columns
                    for (let colIndex = 0; colIndex < lastTableData.pattern.length; colIndex++) {
                        if (lastTableData.pattern[colIndex] === 'T') { // Check if it's a text column
                            let matchCount = 0;
                            
                            // Count matches in this column
                            lastTableData.dataRows.forEach(row => {
                                const value = canonicalize(row[colIndex]);
                                // If the value in the table doesn't match anything in modelDates, canonicalize() will return null as the match
                                if (value) {
                                    matchCount++;
                                }
                            });
                            
                            // Update best column if this one has more matches
                            if (matchCount > bestMatchCount) {
                                bestMatchCount = matchCount;
                                bestColumnIndex = colIndex;
                            }
                        }
                    }
                    
                    // If no good match found, use the first text column
                    if (bestColumnIndex === -1) {
                        bestColumnIndex = lastTableData.pattern.findIndex(type => type === 'T');
                        // If still no text column, just use the first column
                        if (bestColumnIndex === -1) bestColumnIndex = 0;
                    }
                    
                    // 2. Create a new column with dates
                    lastTableData.pattern.splice(bestColumnIndex + 1, 0, 'D'); // Add 'D' type at index + 1
                    lastTableData.columnsPerRow += 1;
                    
                    // Remember to move the indicator for the currently sorted column, if it exists to the right of the new column
                    if (currentSortColumn >= bestColumnIndex + 1) {
                        currentSortColumn++;
                    }
                    
                    // Update current header selections to include the new column
                    currentHeaderSelections.splice(bestColumnIndex + 1, 0, "Release Date");
                    
                    // Store the date column index for later reference
                    dateColumnIndex = bestColumnIndex + 1;
                    
                    // 3. Update each row with the new date column
                    lastTableData.dataRows.forEach(row => {
                        const modelName = row[bestColumnIndex].trim().toLowerCase();
                        const canonical = canonicalize(modelName);
                        let date = "";
                        
                        // Try to find a match in modelDates (direct or partial)
                        if (canonical) {
                            // Use the original key to look up the date
                            date = modelDates[canonical];
                        } else {
                            date = findDate(modelName);
                        }
                        
                        // Insert the date (or empty string for input fields later) after the model name column
                        row.splice(bestColumnIndex + 1, 0, date || "");
                    });
                    
                    // 4. Regenerate the table with the new column
                    const tableElement = generateHTMLTable(lastTableData, editableHeaders);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // 5. Add input fields for unknown dates
                    addDateInputsToEmptyCells();
                    
                    // 6. Update pattern information display
                    let patternDesc = lastTableData.pattern.map(type => {
                        switch(type) {
                            case 'D': return 'Date';
                            case 'N': return 'Number';
                            case 'T': return 'Text';
                            case 'E': return 'Empty';
                            default: return type;
                        }
                    }).join(', ');
                    tableStructure.textContent = `Column Types: ${patternDesc}`;
                    
                    // Hide the add date column button now that we've added one
                    addDateColumnButton.classList.add('hidden');
                    
                } else {
                    // Handle structured data (CSV, TSV, JSON, HTML)
                    if (!structuredData || !structuredData.headers || !structuredData.rows) return false;
                    
                    // 1. Find the best matching column
                    let bestColumnIndex = -1;
                    let bestMatchCount = 0;
                    
                    // Check each column
                    for (let colIndex = 0; colIndex < structuredData.headers.length; colIndex++) {
                        let matchCount = 0;
                        
                        // Count matches in this column
                        structuredData.rows.forEach(row => {
                            if (colIndex < row.length) {
                                const value = canonicalize(row[colIndex]);
                                
                                // If the value in the table doesn't match anything in modelDates, canonicalize() will return null as the match
                                if (value) {
                                    matchCount++;
                                }
                            }
                        });
                        
                        // Update best column if this one has more matches
                        if (matchCount > bestMatchCount) {
                            bestMatchCount = matchCount;
                            bestColumnIndex = colIndex;
                        }
                    }
                    
                    // If no good match found, use the first column
                    if (bestColumnIndex === -1) bestColumnIndex = 0;
                    
                    // 2. Add new column header
                    structuredData.headers.splice(bestColumnIndex + 1, 0, "Release Date");
                    
                    // Store the date column index for later reference
                    dateColumnIndex = bestColumnIndex + 1;
                    
                    // Remember to move the indicator for the currently sorted column, if it exists to the right of the new column
                    if (currentSortColumn >= dateColumnIndex) {
                        currentSortColumn++;
                    }
                    
                    // 3. Update each row with the new date column
                    structuredData.rows.forEach(row => {
                        // Make sure the row has enough columns
                        while (row.length <= bestColumnIndex) {
                            row.push("");
                        }
                        
                        const modelName = row[bestColumnIndex].trim().toLowerCase();
                        const canonical = canonicalize(modelName);
                        let date = "";
                        
                        // Try to find a match in modelDates (direct or partial)
                        if (canonical) {
                            // Use the original key to look up the date
                            date = modelDates[canonical];
                        } else {
                            date = findDate(modelName);
                        }
                        
                        // Add the date column (or empty string for input fields)
                        row.splice(bestColumnIndex + 1, 0, date || "");
                    });
                    
                    // 4. Regenerate the table
                    const tableElement = generateStructuredHTMLTable(structuredData);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // 5. Add input fields for unknown dates
                    addDateInputsToEmptyCells();
                    
                    // Update info display
                    tableStructure.textContent = `${structuredData.headers.length} columns, ${structuredData.rows.length} data rows`;
                    
                    // Hide the add date column button
                    addDateColumnButton.classList.add('hidden');
                }
                
                // Adding a column might have made the Select Columns button relevant
                updateSelectColumnsButton();
                
                return true;
            }
            
            // Function to toggle column selection mode
            function toggleColumnSelection() {
                // Special case of there only being two columns
                const fewStructuredColumns = structuredData && structuredData.headers.length > 0 && structuredData.headers.length < 3;
                const fewColumnsPerRow = lastTableData && lastTableData.columnsPerRow < 3;
                if (fewStructuredColumns || fewColumnsPerRow) {
                    return;
                }
            
                // Before toggling, save any date input values if we're going from input mode to selection mode
                if (!columnSelectionEnabled && dateColumnIndex !== -1) {
                    // Save input values
                    document.querySelectorAll('.date-input').forEach(input => {
                        const rowElement = input.closest('tr');
                        const cellElement = input.closest('td');
                        const rowIndex = Array.from(rowElement.parentNode.children).indexOf(rowElement);
                        const cellIndex = Array.from(rowElement.children).indexOf(cellElement);
                        
                        // Format and save the value
                        const formattedDate = parseAndFormatDate(input.value);
                        
                        // Update the data structure
                        if (currentDataFormat === 'text') {
                            if (lastTableData.dataRows[rowIndex]) {
                                lastTableData.dataRows[rowIndex][cellIndex] = formattedDate;
                            }
                        } else {
                            if (structuredData.rows[rowIndex]) {
                                structuredData.rows[rowIndex][cellIndex] = formattedDate;
                            }
                        }
                    });
                }
                
                // Toggle the selection mode
                columnSelectionEnabled = !columnSelectionEnabled;
                
                // Update button text based on the new state
                toggleColumnsButton.textContent = columnSelectionEnabled ? 'Accept Columns' : 'Select Columns';
                
                // If turning off selection mode, reset the Delete Columns button
                if (!columnSelectionEnabled) {
                    deleteColumnsButton.disabled = true;
                    setDeleteColumnsButton('gray');
                    columnSelectionError.classList.add('hidden');
                    
                    // Uncheck all checkboxes
                    document.querySelectorAll('.column-checkbox').forEach(checkbox => {
                        checkbox.checked = false;
                    });
                }
                
                // Re-render the table to show/hide checkbox row
                if (currentDataFormat === 'text') {
                    if (lastTableData) {
                        const tableElement = generateHTMLTable(lastTableData, editableHeaders);
                        tableContainer.innerHTML = '';
                        tableContainer.appendChild(tableElement);
                    }
                } else {
                    if (structuredData && structuredData.headers && structuredData.rows) {
                        const tableElement = generateStructuredHTMLTable(structuredData);
                        tableContainer.innerHTML = '';
                        tableContainer.appendChild(tableElement);
                    }
                }
                
                // Set up checkbox listeners if checkboxes are shown
                if (columnSelectionEnabled && showColumnCheckboxes) {
                    setupColumnCheckboxes();
                }
                
                // Add date inputs back to empty cells in the date column if we're going from selection mode to input mode
                if (!columnSelectionEnabled && dateColumnIndex !== -1) {
                    addDateInputsToEmptyCells();
                }
            }

            // Function to detect the format of the input data
            function detectDataFormat(inputText) {
                // Remove leading/trailing whitespace
                const trimmedText = inputText.trim();
                
                // If empty, return unknown
                if (!trimmedText) {
                    return { format: 'unknown', confidence: 0 };
                }
                
                // 1. Check if it's JSON (an array with at least 2 elements)
                try {
                    let parsed = JSON.parse(trimmedText);
                    // To be a JSON object, the outermost container must be an object {...} rather than an array [...]
                    if (typeof(parsed) === 'object') {
                        const objectValues = Object.values(parsed);
                        // The object could have many key-value pairs, but we only care about the first pair, and in particular the value half of that pair
                        parsed = objectValues[0];
                    }
                    if (Array.isArray(parsed) && parsed.length >= 2) {
                        return { format: 'json', confidence: 0.9 };
                    }
                } catch (e) {
                    // Not valid JSON, continue with other checks
                }
                
                // Split into lines for further analysis
                const lines = trimmedText.split('\n').filter(line => line.trim() !== '');
                
                // If no valid lines, return unknown
                if (lines.length === 0) {
                    return { format: 'unknown', confidence: 0 };
                }
                
                // 2. Check if it's TSV (at least 5 lines, and at least 55% contain 2+ tabs)
                if (lines.length >= 5) {
                    const linesWithTwoTabs = lines.filter(line => 
                        (line.match(/\t/g) || []).length >= 2
                    ).length;
                    
                    const tabPercentage = linesWithTwoTabs / lines.length;
                    
                    if (tabPercentage >= 0.55) {
                        return { 
                            format: 'tsv', 
                            confidence: tabPercentage,
                            stats: {
                                total: lines.length,
                                withTabs: linesWithTwoTabs,
                                percentage: tabPercentage
                            }
                        };
                    }
                }
                
                // 2b. Special case for a minimal strict TSV, meaning exactly 1 tab on every line, no unusual characters
                if (lines.length >= 5) {
                    const linesWithOneTab = lines.filter(line => 
                        // The whole line must be {a section without angle brackets, commas, or tabs} then a tab then {a section without etc.}
                        line.match(/^[^,<>\t]*\t[^,<>\t]*$/)
                    ).length;
                    
                    const simpleTsvPercentage = linesWithOneTab / lines.length;
                    
                    // As this is a special case, it should only be triggered if the confidence is high
                    if (simpleTsvPercentage >= 0.9) {
                        return { 
                            format: 'tsv', 
                            confidence: simpleTsvPercentage,
                            stats: {
                                total: lines.length,
                                withTabs: linesWithOneTab,
                                percentage: simpleTsvPercentage
                            }
                        };
                    }
                }
                
                // 3. Check if it's CSV (at least 5 lines, and at least 55% contain 2+ commas)
                if (lines.length >= 5) {
                    const linesWithTwoCommas = lines.filter(line => 
                        (line.match(/,/g) || []).length >= 2
                    ).length;
                    
                    const commaPercentage = linesWithTwoCommas / lines.length;
                    
                    if (commaPercentage >= 0.55) {
                        return { 
                            format: 'csv', 
                            confidence: commaPercentage,
                            stats: {
                                total: lines.length,
                                withCommas: linesWithTwoCommas,
                                percentage: commaPercentage
                            }
                        };
                    }
                }
                
                // 3b. Special case of a CSV with only 2 columns (presumably just a date and a number, therefore no model names to confuse things)
                if (lines.length >= 5) {
                    const linesWithOneComma = lines.filter(line => 
                        // The whole line must be {a section without angle brackets, commas, or tabs} then a comma then {a section without etc.}
                        line.match(/^[^,<>\t]*,[^,<>\t]*$/)
                    ).length;
                    
                    const simpleCsvPercentage = linesWithOneComma / lines.length;
                    
                    // As this is a special case, it should only be triggered if the confidence is high
                    if (simpleCsvPercentage >= 0.9) {
                        return { 
                            format: 'csv', 
                            confidence: simpleCsvPercentage,
                            stats: {
                                total: lines.length,
                                withCommas: linesWithOneComma,
                                percentage: simpleCsvPercentage
                            }
                        };
                    }
                }
                
                // 3c. Special case for a very short table of CSV data just to make a point
                if (lines.length > 1 && lines.length < 5) {
                    const commasPerLine = lines.map(line => line.split("").filter(char => char == ",").length);
                    const firstCount = commasPerLine[0];
                    const sameNumberOfCommas = commasPerLine.every(count => count == firstCount);
                    if (sameNumberOfCommas && firstCount >= 2) {
                        // Every line has the same number of commas as the first line, and there are at least 3 columns
                        return { 
                            format: 'csv', 
                            confidence: 1,
                            stats: {
                                total: lines.length,
                                withCommas: lines.length,
                                percentage: 1
                            }
                        };
                    }
                }
                
                // 4. Check if it's HTML (at least 50% of rows contain the regex "<.*>.*<.*>")
                const htmlTablePattern = /<table[\s>]/i;
                if (htmlTablePattern.test(trimmedText)) {
                    return { 
                        format: 'html', 
                        confidence: 0.9
                    };
                }
                
                // If the input is HTML, then most lines should either be just a single tag (with possible whitespace), or at least two tags
                // Someone might call their model <Agent1> but there shouldn't be too many such misinterpretable strings
                const oneTagPattern = /^<[a-zA-Z/]*>$/;
                const twoTagsPattern = /<.*>.*<.*>/;
                const linesWithHtmlTags = lines.filter(line => 
                    oneTagPattern.test(line.trim()) || twoTagsPattern.test(line)
                ).length;
                
                const htmlPercentage = linesWithHtmlTags / lines.length;
                
                if (htmlPercentage >= 0.5) {
                    return { 
                        format: 'html', 
                        confidence: htmlPercentage,
                        stats: {
                            total: lines.length,
                            withHtml: linesWithHtmlTags,
                            percentage: htmlPercentage
                        }
                    };
                }
                
                // 5. Default to text (the least structured format, useful for copy-pasting from a website)
                return { format: 'text', confidence: 1.0 };
            }
            
            // CSV Parser
            function parseCSV(csvText) {
                // Split the text into lines
                const lines = csvText.trim().split('\n');
                if (lines.length === 0) {
                    throw new Error("CSV is empty");
                }
                
                // Parse each line, handling quoted values with commas
                const parseCSVLine = (line) => {
                    const values = [];
                    let currentValue = "";
                    let inQuotes = false;
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        
                        if (char === '"') {
                            // Check for escaped quotes (double quotes)
                            if (i + 1 < line.length && line[i + 1] === '"') {
                                currentValue += '"';
                                i++; // Skip the next quote
                            } else {
                                // Toggle quote state
                                inQuotes = !inQuotes;
                            }
                        } else if (char === ',' && !inQuotes) {
                            // End of value
                            values.push(currentValue);
                            currentValue = "";
                        } else {
                            // Regular character
                            currentValue += char;
                        }
                    }
                    
                    // Don't forget the last value
                    values.push(currentValue);
                    
                    return values;
                };
                
                // Parse headers and data rows
                const headers = parseCSVLine(lines[0]);
                const rows = [];
                
                // Parse data rows (skip header row)
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim() !== '') {
                        rows.push(parseCSVLine(lines[i]));
                    }
                }
                
                return { headers, rows };
            }
            
            // TSV Parser
            function parseTSV(tsvText) {
                // Split the text into lines
                const lines = tsvText.trim().split('\n');
                if (lines.length === 0) {
                    throw new Error("TSV is empty");
                }
                
                // Parse each line, simply splitting by tabs
                const parseTSVLine = (line) => {
                    // Simple split by tab character
                    return line.split('\t');
                };
                
                // Parse headers and data rows
                const headers = parseTSVLine(lines[0]);
                const rows = [];
                
                // Parse data rows (skip header row)
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim() !== '') {
                        rows.push(parseTSVLine(lines[i]));
                    }
                }
                
                return { headers, rows };
            }
            
            // JSON Parser
            function parseJSON(jsonText) {
                try {
                    let data = JSON.parse(jsonText);
                    
                    // To be a JSON object, the outermost container must be an object {...} rather than an array [...]
                    if (typeof(data) === 'object') {
                        const objectValues = Object.values(data);
                        // The object could have many key-value pairs, but we only care about the first pair, and in particular the value half of that pair
                        data = objectValues[0];
                    }
                    
                    if (!Array.isArray(data) || data.length === 0) {
                        throw new Error("JSON must be an array of objects");
                    }
                    
                    // Get all possible headers from all objects
                    const headerSet = new Set();
                    data.forEach(item => {
                        if (typeof item === 'object' && item !== null) {
                            Object.keys(item).forEach(key => headerSet.add(key));
                        }
                    });
                    
                    const headers = Array.from(headerSet);
                    
                    // Convert data to rows
                    const rows = data.map(item => {
                        if (typeof item === 'object' && item !== null) {
                            return headers.map(header => 
                                item[header] !== undefined ? String(item[header]) : ''
                            );
                        } else {
                            // Handle non-object items in the array
                            return [String(item)];
                        }
                    });
                    
                    return { headers, rows };
                    
                } catch (e) {
                    throw new Error(`Error parsing JSON: ${e.message}`);
                }
            }
            
            // HTML Table Parser - safely extracts text from HTML tables
            function parseHTMLTable(htmlText) {
                try {
                    // Create a DOM parser and a new document
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlText, 'text/html');
                    
                    // Find tables
                    let tables = doc.querySelectorAll('table');
                    
                    if (tables.length === 0) {
                        console.log("No HTML table found in the input. Wrapping in <table>...</table> to try again.");
                        // Trying to build a document from a string containing no root tag is not easily recoverable, so it is cleaner to start again
                        const wrappedHtmlText = `<table>${htmlText}</table>`;
                        const wrappedDoc = parser.parseFromString(wrappedHtmlText, 'text/html');
                        tables = wrappedDoc.querySelectorAll('table');
                    }
                    
                    // Use the first table found
                    const table = tables[0];
                    
                    // Extract headers from table headers or first row
                    const headerRow = table.querySelector('thead tr') || table.querySelector('tr');
                    if (!headerRow) {
                        throw new Error("No rows found in the HTML table");
                    }
                    
                    // Get text from headers, safely ignoring tags
                    const headers = Array.from(headerRow.querySelectorAll('th, td')).map(cell => 
                        cell.textContent.trim()
                    );
                    
                    // Extract data rows (skip header row if we used it for headers)
                    const rows = [];
                    // <tr>s can appear in the <tbody> or as direct descendents of the <table>
                    // Unfortunately they can also appear in the <thead> and <tfoot>, so just searching for <tr> will create false positives or duplicates
                    const dataRows = table.querySelectorAll('tr:not(thead tr, tfoot tr)');
                    
                    let startIndex = 0;
                    if (!table.querySelector('thead') && dataRows.length > 0) {
                        // If we used the first row for headers and there's no thead
                        startIndex = 1;
                    }
                    
                    for (let i = startIndex; i < dataRows.length; i++) {
                        const rowCells = dataRows[i].querySelectorAll('td, th');
                        const rowData = Array.from(rowCells).map(cell => 
                            cell.textContent.trim()
                        );
                        
                        // Only add if row has data
                        if (rowData.some(cell => cell !== '')) {
                            rows.push(rowData);
                        }
                    }
                    
                    return { headers, rows };
                    
                } catch (e) {
                    throw new Error(`Error parsing HTML table: ${e.message}`);
                }
            }
            
            // Function to check if we should show column checkboxes (3+ columns)
            function shouldShowColumnCheckboxes(columnCount) {
                return columnCount >= 3;
            }
            
            // Function to check whether the table has any Date columns in it
            function checkContainsDateFormatCell(rows) {
                // There's also the special case of a 2 column table where neither column is of the type Date
                // That requires the columnActionContainer to be visible so that the Add Date Column button can be seen
                const firstRowWithoutAnyEmptyCells = rows.find(row => row.every(cell => cell.length != 0)) || [];
                const containsDateFormatCell = firstRowWithoutAnyEmptyCells.some(cell => classifyCell(cell) == 'D');
                return containsDateFormatCell;
            }
            
            // Function to update the delete button UI based on checkbox state
            function updateDeleteButtonState() {
                const checkedBoxes = document.querySelectorAll('.column-checkbox:checked');
                const totalColumns = document.querySelectorAll('.column-checkbox').length;
                const columnsRemaining = totalColumns - checkedBoxes.length;
                
                if (checkedBoxes.length > 0) {
                    // At least one column is checked
                    setDeleteColumnsButton('red');
                    
                    // Check if we would have fewer than 2 columns left
                    if (columnsRemaining < 2) {
                        deleteColumnsButton.disabled = true;
                        columnSelectionError.classList.remove('hidden');
                    } else {
                        deleteColumnsButton.disabled = false;
                        columnSelectionError.classList.add('hidden');
                    }
                } else {
                    // No columns checked
                    setDeleteColumnsButton('gray');
                    deleteColumnsButton.disabled = true;
                    columnSelectionError.classList.add('hidden');
                }
            }
            
            // Flip the classes on the button so it appears either red and gray, as specified
            function setDeleteColumnsButton(color) {
                if (color === 'red') {
                    deleteColumnsButton.classList.remove('bg-gray-200', 'dark:bg-gray-700');
                    deleteColumnsButton.classList.add('bg-red-500', 'hover:bg-red-600', 'dark:bg-red-600', 'dark:hover:bg-red-700', 'text-white');
                } else {
                    deleteColumnsButton.classList.remove('bg-red-500', 'hover:bg-red-600', 'dark:bg-red-600', 'dark:hover:bg-red-700', 'text-white');
                    deleteColumnsButton.classList.add('bg-gray-200', 'dark:bg-gray-700');
                }
            }
            
            // Function to add checkbox event listeners
            function setupColumnCheckboxes() {
                document.querySelectorAll('.column-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', updateDeleteButtonState);
                });
            }
            
            // Function to classify a cell value
            function classifyCell(value) {
                // Remove leading/trailing whitespace for classification
                value = value.trim();
                
                // Check if empty after trimming
                if (value === '' || value === 'N/A') return 'E'; // Empty
                
                // Simple case of it ending in a % symbol, in which case treat it as a percentage
                if (value.substr(-1) === '%') return 'N'; // Numeric
                
                // Another special case of a number with a confidence interval (no commas, but possibly parentheses)
                if (/^[0-9. ()]*±[0-9. ()]*$/.test(value)) return 'N';
                
                // Yet another special case, a number with a leading currency symbol (assume only dollars for now)
                if (/^\$[0-9.]*$/.test(value)) return 'N';
                
                // Check if it's a number
                // If the data has a separator for long numbers, assume it is a comma at every third power of 10
                if (/^[0-9,]*\.?[0-9]*$/.test(value)) {
                    // The string is just digits (possibly with commas in its integer part) and a possible decimal point
                    if (value.includes(',')) {
                        // Check what sizes the commas split the numeric string into
                        const triples = value.split(',').map(triple => triple.length);
                        if (triples[0] < 4 && triples.slice(1).every(len => len === 3)) {
                            // Strip the commas and continue with the normal detection process as if they were never there
                            value = value.replaceAll(',', '');
                        } else {
                            // The commas are in the wrong place for this to be a valid number, so treat it as text
                            // Maybe it was a model called "1,2,3"
                            return 'T';
                        }
                    }
                }
                if (!isNaN(parseFloat(value)) && isFinite(value)) return 'N';
                
                // Check if it's a date (multiple formats)
                const datePatterns = [
                    /^\d{1,2}[-/\.]\d{1,2}[-/\.]\d{2,4}$/, // MM/DD/YYYY, DD/MM/YYYY
                    /^\d{4}[-/\.]\d{1,2}[-/\.]\d{1,2}$/, // YYYY/MM/DD
                    /^[a-zA-Z]{3,9}\s+\d{1,2},?\s+\d{4}$/, // Month DD, YYYY
                    /^\d{1,2}\s+[a-zA-Z]{3,9},?\s+\d{4}$/, // DD Month YYYY
                ];
                
                for (const pattern of datePatterns) {
                    const asciiValue = value.replace(/[^\x00-\x7F]/g, "").trim();
                    if (pattern.test(asciiValue)) return 'D';
                }
                
                // Default to text
                return 'T';
            }

            // Helper function for dealing with finding an array's elements in order inside another array
            function isSubsequence(subArray, mainArray) {
                let subIndex = 0;
                for (let i = 0; i < mainArray.length; i++) {
                    if (mainArray[i] === subArray[subIndex]) {
                        subIndex++;
                    }
                    if (subIndex === subArray.length) {
                        return true;
                    }
                }
                return false;
            }

            // Function to find the fundamental repeating pattern
            function findRepeatingPattern(sequence) {
                // For diagnostics - store the original sequence
                window.fullSequence = [...sequence];
                
                // Skip potential header rows at the beginning (maximum of 10 rows to be safe)
                // But don't skip too many even if they're text
                let dataStartIndex = 0;
                let headerTextCount = 0;
                while (dataStartIndex < Math.min(10, sequence.length) && sequence[dataStartIndex] === 'T') {
                    dataStartIndex++;
                    headerTextCount++;
                }
                
                // Focus on the main data section, skipping headers
                const dataSequence = sequence.slice(dataStartIndex);
                if (dataSequence.length === 0) return null;
                
                // Store for diagnostics
                window.dataSequence = [...dataSequence];
                
                // Track pattern candidates
                const patternCandidates = [];
                
                // Try different pattern lengths, starting with shorter patterns (more likely to be fundamental)
                for (let len = 1; len <= Math.min(20, Math.floor(dataSequence.length / 2)); len++) {
                    // Extract the first potential pattern of this length
                    const potentialPattern = dataSequence.slice(0, len);
                    
                    // Count how much of the sequence can be explained by this pattern
                    let matchedCount = 0;
                    let consecutiveBlocks = 0;
                    
                    for (let i = 0; i < dataSequence.length - len + 1; i += len) {
                        const segment = dataSequence.slice(i, i + len);
                        if (arraysEqual(segment, potentialPattern)) {
                            matchedCount += len;
                            consecutiveBlocks++;
                        } else {
                            break; // Stop at first non-match when checking consecutive matches
                        }
                    }
                    
                    // Non-consecutive matching (for patterns that might appear multiple times)
                    let totalMatches = 0;
                    let pos = 0;
                    const patternStr = potentialPattern.join('');
                    const sequenceStr = dataSequence.join('');
                    
                    // Count actual occurrences
                    while (true) {
                        pos = sequenceStr.indexOf(patternStr, pos);
                        if (pos === -1) break;
                        totalMatches++;
                        pos += patternStr.length; // Move past the current match completely
                    }
                    
                    // Calculate coverage percentage (how much of the sequence this pattern explains)
                    const coveragePercentage = (matchedCount / dataSequence.length) * 100;
                    
                    // Consider patterns with significant coverage (at least 30%)
                    // This ensures the pattern is meaningful and not just random matches
                    if ((coveragePercentage >= 30 && totalMatches >= 2) || consecutiveBlocks >= 3) {
                        patternCandidates.push({
                            pattern: potentialPattern,
                            length: len,
                            coverage: coveragePercentage,
                            matches: totalMatches,
                            consecutiveBlocks: consecutiveBlocks
                        });
                    }
                }
                
                console.log("All pattern candidates:", patternCandidates);
                
                if (patternCandidates.length === 0) return null;
                
                // Sort candidates: prioritize a mix of factors
                patternCandidates.sort((a, b) => {
                    // First, prioritize patterns with at least 3 consecutive blocks
                    if (a.consecutiveBlocks >= 3 && b.consecutiveBlocks < 3) return -1;
                    if (b.consecutiveBlocks >= 3 && a.consecutiveBlocks < 3) return 1;
                    
                    // Then look at coverage - if > 5% difference, prefer higher coverage
                    if (Math.abs(a.coverage - b.coverage) > 5) {
                        return b.coverage - a.coverage;
                    }
                    
                    // Otherwise prefer shorter patterns with similar coverage
                    return a.length - b.length;
                });
                
                const bestCandidate = patternCandidates[0];
                console.log("Best pattern candidate:", bestCandidate);
                
                let bestPattern = bestCandidate.pattern;
                
                // Try to synch the pattern with the specific cells at the end of the sequence
                const finalRowPattern = sequence.splice(sequence.length - bestPattern.length);
                const doubledArray = finalRowPattern.concat(finalRowPattern);
                const finalRowPatternIsCycleOfBestPattern = isSubsequence(bestPattern, doubledArray);
                
                if (finalRowPatternIsCycleOfBestPattern) {
                    bestPattern = finalRowPattern;
                }
                
                // Return the best candidate even with low coverage
                return bestPattern;
            }
            
            // Helper function to check if two arrays are equal
            function arraysEqual(a, b) {
                if (a.length !== b.length) return false;
                for (let i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) return false;
                }
                return true;
            }

            // Helper function while Array.prototype.chunk() doesn't exist
            function chunk(array, size) {
                const chunkedArray = [];
                for (let i = 0; i < array.length; i += size) {
                    chunkedArray.push(array.slice(i, i + size));
                }
                return chunkedArray;
            }

            // Function to organize data into a table with pattern alignment
            function organizeDataIntoTable(lines, pattern) {
                // Get the columns count from pattern length
                const columnsPerRow = pattern ? pattern.length : 1;
                
                // Work backwards from the end of the data
                const reversedChunks = chunk(lines.reverse(), columnsPerRow);
                // The chunks at the end are now header cells, of which there might be too many or too few
                let dataRows = [];
                let headerChunks = [];
                
                for (let i = 0; i < reversedChunks.length; i++) {
                    // Because the whole sequence was reversed, that means the elements within each chunk need to be restored
                    let currentChunk = reversedChunks[i].reverse();
                    let validChunk = true;
                    for (let j = 0; j < currentChunk.length; j++) {
                        if (currentChunk.length != pattern.length || classifyCell(currentChunk[j]) != pattern[j]) {
                            validChunk = false;
                            break;
                        }
                    }
                    if (validChunk) {
                        dataRows.push(currentChunk);
                    } else {
                        headerChunks.push(currentChunk);
                    }
                }
                dataRows.reverse();
                headerChunks = headerChunks.reverse();
                
                // Collect all potential headers from headerChunks
                const headers = [];
                
                // Extract all text values from headerChunks
                headerChunks.forEach(chunk => {
                    chunk.forEach(value => {
                        if (value.trim() !== '') {
                            headers.push(value);
                        }
                    });
                });
                
                // Get all unique headers
                const uniqueHeaders = [...new Set(headers)];
                
                return {
                    columnsPerRow: columnsPerRow,
                    headers: uniqueHeaders,
                    dataRows: dataRows,
                    pattern: pattern  // Include the pattern in the result
                };
            }

            // Function to intelligently select default headers based on column types
            function selectDefaultHeaders(tableData) {
                const { headers, pattern } = tableData;
                
                // Simple case where the parsing process found the right number of headers, therefore they are most likely in the correct order
                if (pattern.length == headers.length) {
                    return headers;
                }
                
                const defaults = [];
                const usedHeaders = new Set(); // Track already used headers
                
                // Process each column based on its type
                for (let i = 0; i < pattern.length; i++) {
                    const colType = pattern[i];
                    let bestHeader = '';
                    
                    // Date column - look for headers containing "date" (case insensitive)
                    if (colType === 'D') {
                        const dateHeader = headers.find(h => 
                            h.toLowerCase().includes('date') && !usedHeaders.has(h)
                        );
                        if (dateHeader) {
                            bestHeader = dateHeader;
                            dateColumnIndex = i; // Track the date column index
                        }
                    } 
                    // Number column - look for headers containing value-related terms
                    else if (colType === 'N') {
                        const numberKeywords = ['value', 'score', 'percent', '%', 'number', 'amount', 'rate', 'price'];
                        
                        // Try to find a header with any of the number keywords
                        for (const keyword of numberKeywords) {
                            const numberHeader = headers.find(h => 
                                h.toLowerCase().includes(keyword) && !usedHeaders.has(h)
                            );
                            if (numberHeader) {
                                bestHeader = numberHeader;
                                break;
                            }
                        }
                    }
                    
                    // If we didn't find a type-specific header, try the next unused header
                    if (!bestHeader) {
                        bestHeader = headers.find(h => !usedHeaders.has(h) && h.trim() !== '') || '';
                    }
                    
                    // If we still don't have a header, use placeholder string
                    if (!bestHeader) {
                        bestHeader = 'Unknown column ' + (i + 1);
                    }
                    
                    // If we have a valid non-empty header, mark it as used
                    if (bestHeader && bestHeader.trim() !== '') {
                        usedHeaders.add(bestHeader);
                    }
                    
                    defaults.push(bestHeader);
                }
                
                return defaults;
            }

            // Function to delete selected columns
            function deleteSelectedColumns() {
                // Get all checked column checkboxes
                const checkedCheckboxes = document.querySelectorAll('.column-checkbox:checked');
                const columnsToDelete = Array.from(checkedCheckboxes).map(
                    checkbox => parseInt(checkbox.dataset.columnIndex)
                ).sort((a, b) => b - a); // Sort in descending order to delete from right to left
                
                if (columnsToDelete.length === 0) {
                    alert("Please select at least one column to delete.");
                    return;
                }
                
                // Check if we're deleting the date column
                const isDeletingDateColumn = columnsToDelete.includes(dateColumnIndex);
                
                // Before regenerating the table, calculate the new index for the column that the table is being sorted by (if it exists)
                if (currentSortColumn) {
                    if (columnsToDelete.includes(currentSortColumn)) {
                        currentSortColumn = -1;
                        currentSortDirection = '';
                    } else {
                        const columnsLeftOfDeletionPoint = columnsToDelete.filter(index => index < currentSortColumn).length;
                        currentSortColumn = currentSortColumn - columnsLeftOfDeletionPoint;
                    }
                }
                
                // For text data format
                if (currentDataFormat === 'text') {
                    if (!lastTableData) return;
                    
                    // Remove columns from data rows
                    lastTableData.dataRows = lastTableData.dataRows.map(row => {
                        return row.filter((_, index) => !columnsToDelete.includes(index));
                    });
                    
                    // Update the pattern
                    lastTableData.pattern = lastTableData.pattern.filter((_, index) => 
                        !columnsToDelete.includes(index)
                    );
                    
                    // Update columnsPerRow
                    lastTableData.columnsPerRow = lastTableData.pattern.length;
                    
                    // Update header selections
                    currentHeaderSelections = currentHeaderSelections.filter((_, index) => 
                        !columnsToDelete.includes(index)
                    );
                    
                    // Reset to selection mode off after deletion
                    columnSelectionEnabled = false;
                    toggleColumnsButton.textContent = 'Select Columns';
                    
                    // Regenerate the table
                    const tableElement = generateHTMLTable(lastTableData, editableHeaders);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                } else {
                    // For structured data formats (CSV, JSON, HTML, TSV)
                    if (!structuredData || !structuredData.headers || !structuredData.rows) return;
                    
                    // Remove columns from headers
                    structuredData.headers = structuredData.headers.filter((_, index) => 
                        !columnsToDelete.includes(index)
                    );
                    
                    // Remove columns from data rows
                    structuredData.rows = structuredData.rows.map(row => {
                        return row.filter((_, index) => !columnsToDelete.includes(index));
                    });
                    
                    // Reset to selection mode off after deletion
                    columnSelectionEnabled = false;
                    toggleColumnsButton.textContent = 'Select Columns';
                    
                    // Regenerate the table
                    const tableElement = generateStructuredHTMLTable(structuredData);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                }
                
                // Update info display
                if (currentDataFormat === 'text') {
                    let patternDesc = lastTableData.pattern.map(type => {
                        switch(type) {
                            case 'D': return 'Date';
                            case 'N': return 'Number';
                            case 'T': return 'Text';
                            case 'E': return 'Empty';
                            default: return type;
                        }
                    }).join(', ');
                    tableStructure.textContent = `Column Types: ${patternDesc}`;
                } else {
                    tableStructure.textContent = `${structuredData.headers.length} columns, ${structuredData.rows.length} data rows`;
                }
                
                // If checkboxes are shown, set up listeners again
                if (columnSelectionEnabled && showColumnCheckboxes) {
                    setupColumnCheckboxes();
                }
                
                // If we deleted the date column, update the date column index and check if we need to show the Add Date Column button
                if (isDeletingDateColumn) {
                    if (currentDataFormat === 'text') {
                        // Find if there's still a date column
                        dateColumnIndex = lastTableData.pattern.indexOf('D');
                    } else {
                        // Find if there's still a "Release Date" column
                        dateColumnIndex = structuredData.headers.indexOf("Release Date");
                    }
                    
                    // Show the Add Date Column button if no date column exists
                    checkForDateColumn();
                } else if (dateColumnIndex !== -1) {
                    // Update dateColumnIndex if necessary (columns were deleted before it)
                    const deletedBeforeDateColumn = columnsToDelete.filter(index => index < dateColumnIndex).length;
                    dateColumnIndex -= deletedBeforeDateColumn;
                }
                
                // Deleting the selected columns causes the selection to necessarily disappear, so the button state must be updated
                updateDeleteButtonState();
                
                // Also potentially update the state of the Select Columns button
                updateSelectColumnsButton();
                
                // Reset current sort state
                currentSortColumn = -1;
                currentSortDirection = '';
            }

            // Function to convert cell value to CSV format (escaping commas, quotes, etc.)
            function escapeCSV(cell) {
                // Convert to string
                cell = String(cell);
                
                // Handle \n characters
                cell = cleanMultiLine(cell);
                
                // If cell contains commas, quotes, or newlines, enclose in quotes
                if (cell.includes(',') || cell.includes('"') || cell.includes('\n')) {
                    // Double any quotes inside the cell
                    cell = cell.replace(/"/g, '""');
                    // Wrap the cell in quotes
                    return `"${cell}"`;
                }
                return cell;
            }

            // Function to convert the table data to CSV
            function convertToCSV() {
                let emptyRows = 0;
                
                if (currentDataFormat === 'text') {
                    // Use the lastTableData for text format
                    if (!lastTableData) return '';
                    
                    const { dataRows } = lastTableData;
                    const rows = [];
                    
                    // Add header row with currently selected headers
                    rows.push(currentHeaderSelections.map(escapeCSV).join(','));
                    
                    // Add data rows
                    dataRows.forEach(row => {
                        if (!row || !row.length) {
                            emptyRows++;
                            return;
                        }
                        rows.push(row.map(escapeCSV).join(','));
                    });
                    console.log('Skipped empty rows from CSV output:', emptyRows);
                    
                    return rows.join('\n');
                } else {
                    // Use the structured data for other formats
                    if (!structuredData || !structuredData.headers || !structuredData.rows) {
                        return '';
                    }
                    
                    const rows = [];
                    
                    // Add header row
                    rows.push(structuredData.headers.map(escapeCSV).join(','));
                    
                    // Add data rows
                    structuredData.rows.forEach(row => {
                        if (!row || !row.length) {
                            emptyRows++;
                            return;
                        }
                        rows.push(row.map(escapeCSV).join(','));
                    });
                    console.log('Skipped empty rows from CSV output:', emptyRows);
                    
                    return rows.join('\n');
                }
            }

            // Function to convert the table data to JSON
            function convertToJSON() {
                let emptyRows = 0;
                
                if (currentDataFormat === 'text') {
                    // Use the lastTableData for text format
                    if (!lastTableData) return '';
                    
                    const { dataRows } = lastTableData;
                    const result = [];
                    
                    // Use currentHeaderSelections as property names
                    const headers = currentHeaderSelections.map((header, index) => 
                        header.trim() === '' ? `column${index + 1}` : header
                    );
                    
                    // Convert each row to an object with header-based properties
                    dataRows.forEach(row => {
                        if (!row || !row.length) {
                            emptyRows++;
                            return;
                        }
                        const rowObj = {};
                        row.forEach((cell, index) => {
                            // Attempt to convert numeric values to actual numbers
                            if (classifyCell(cell) === 'N') {
                                rowObj[headers[index]] = parseFloat(cell);
                            } else {
                                rowObj[headers[index]] = cell;
                            }
                        });
                        result.push(rowObj);
                    });
                    console.log('Skipped empty rows from JSON output:', emptyRows);
                    
                    return JSON.stringify(result, null, 2); // Pretty print with 2-space indentation
                } else {
                    // Use the structured data for other formats
                    if (!structuredData || !structuredData.headers || !structuredData.rows) {
                        return '';
                    }
                    
                    const result = [];
                    
                    // Convert each row to an object with header-based properties
                    structuredData.rows.forEach(row => {
                        if (!row || !row.length) {
                            emptyRows++;
                            return;
                        }
                        const rowObj = {};
                        structuredData.headers.forEach((header, index) => {
                            const cleanHeader = cleanMultiLine(header);
                            const headerKey = cleanHeader === '' ? `column${index + 1}` : cleanHeader;
                            // Attempt to convert numeric values to actual numbers
                            if (index < row.length) {
                                if (!isNaN(parseFloat(row[index])) && isFinite(row[index])) {
                                    rowObj[headerKey] = parseFloat(row[index]);
                                } else {
                                    rowObj[headerKey] = row[index];
                                }
                            } else {
                                rowObj[headerKey] = '';
                            }
                        });
                        result.push(rowObj);
                    });
                    console.log('Skipped empty rows from JSON output:', emptyRows);
                    
                    return JSON.stringify(result, null, 2); // Pretty print with 2-space indentation
                }
            }

            // Function to toggle between editable and static headers
            function toggleHeaderMode() {
                // Toggle the state
                editableHeaders = !editableHeaders;
                
                // Save current selections if in editable mode before toggling
                if (editableHeaders === false) {
                    // Read all dropdown values
                    document.querySelectorAll('select[id^="header-select-"]').forEach(select => {
                        const columnIndex = parseInt(select.dataset.column);
                        currentHeaderSelections[columnIndex] = select.value;
                    });
                }
                
                // Regenerate the table with the new mode
                if (lastTableData) {
                    const tableElement = generateHTMLTable(lastTableData, editableHeaders);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // If checkboxes are shown, set up listeners again
                    if (columnSelectionEnabled && showColumnCheckboxes) {
                        setupColumnCheckboxes();
                    }
                    
                    // Add date inputs back to empty cells in the date column
                    if (!columnSelectionEnabled && dateColumnIndex !== -1) {
                        addDateInputsToEmptyCells();
                    }
                }
                
                // Update button text
                toggleHeadersButton.textContent = editableHeaders ? 'Keep Headings' : 'Edit Headings';
            }
            
            // Function to check if there's a date column and show/hide the Add Date Column button
            function checkForDateColumn() {
                let hasDateColumn = false;
                
                if (currentDataFormat === 'text') {
                    if (lastTableData && lastTableData.pattern) {
                        hasDateColumn = lastTableData.pattern.includes('D');
                    }
                } else {
                    // For structured data formats, check each cell in the first few rows to see if any are dates
                    if (structuredData && structuredData.rows && structuredData.rows.length > 0) {
                        const sampleRows = structuredData.rows.slice(0, Math.min(5, structuredData.rows.length));
                        
                        sampleRows.forEach(row => {
                            row.forEach(cell => {
                                if (classifyCell(cell) === 'D') {
                                    hasDateColumn = true;
                                }
                            });
                        });
                    }
                }
                
                // Show or hide the button based on whether a date column exists
                if (hasDateColumn) {
                    addDateColumnButton.classList.add('hidden');
                } else {
                    // To show the Add Date Column, its container must also be visible
                    columnActionContainer.classList.remove('hidden');
                    addDateColumnButton.classList.remove('hidden');
                }
            }

            // Main parse function
            function parseData() {
                const inputText = dataInput.value.trim();
                
                if (!inputText) {
                    showError("Please paste some data to parse.");
                    return;
                }
                
                // Detect the format of the input data
                const detectionResult = detectDataFormat(inputText);
                console.log("Detected format:", detectionResult);
                currentDataFormat = detectionResult.format;
                
                // Hide any previous messages and results
                formatDetectionMessage.classList.add('hidden');
                errorMessage.classList.add('hidden');
                resultSection.classList.add('hidden');
                exportOutputContainer.classList.add('hidden');
                chartContainer.classList.add('hidden');
                
                // Show loading indicator
                loadingIndicator.classList.remove('hidden');
                
                // Reset state when parsing new data
                editableHeaders = true;
                currentHeaderSelections = [];
                toggleHeadersButton.textContent = 'Keep Headings';
                columnSelectionEnabled = false; // Reset column selection mode
                toggleColumnsButton.textContent = 'Select Columns';
                dateColumnIndex = -1; // Reset date column index
                showFrontierOnly = true; // Reset frontier mode to default on
                frontierToggleCheckbox.checked = true; // Reset checkbox to checked
                
                // Reset sorting state
                currentSortColumn = -1;
                currentSortDirection = '';
                
                // Process asynchronously to not block the UI
                setTimeout(() => {
                    try {
                        let parseSuccessful = null;
                    
                        // Choose parser based on detected format
                        switch (detectionResult.format) {
                            case 'csv':
                                parseSuccessful = handleCSVFormat(inputText);
                                break;
                            case 'tsv':
                                parseSuccessful = handleTSVFormat(inputText);
                                break;
                            case 'json':
                                parseSuccessful = handleJSONFormat(inputText);
                                break;
                            case 'html':
                                parseSuccessful = handleHTMLFormat(inputText);
                                break;
                            case 'text':
                            default:
                                parseSuccessful = handleTextFormat(inputText);
                                break;
                        }
                        // Update the UI to show the correct components for the next stage of the process
                        if (parseSuccessful) {
                            showInputContainer.classList.remove('hidden');
                            inputContainer.classList.add('hidden');
                            hideInputButton.classList.remove('hidden');
                            
                            // Check for initial sort order
                            setTimeout(checkInitialSortOrder, 0);
                            
                            // Check if we need to show the Add Date Column button
                            checkForDateColumn();
                            
                            // The ability to use the Select Columns button depends on how many columns were just created
                            setTimeout(updateSelectColumnsButton, 0);
                        }
                    } catch (error) {
                        showError(`Error parsing data: ${error.message}`);
                    } finally {
                        loadingIndicator.classList.add('hidden');
                    }
                }, 50); // Small delay to allow the UI to update
            }
            
            // Handler for CSV format
            function handleCSVFormat(csvText) {
                try {
                    // Parse CSV
                    const data = parseCSV(csvText);
                    
                    // Store structured data for export
                    structuredData = data;
                    
                    // Generate table HTML
                    const tableElement = generateStructuredHTMLTable(data);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // Show format info
                    patternInfo.textContent = `CSV Format Detected`;
                    tableStructure.textContent = `${data.headers.length} columns, ${data.rows.length} data rows`;
                    
                    // Hide toggle headers button (not needed for structured formats)
                    toggleHeadersButton.classList.add('hidden');
                    
                    // Show results
                    resultSection.classList.remove('hidden');
                    
                } catch (error) {
                    showError(`Error parsing CSV: ${error.message}`);
                    return false;
                }
                return true;
            }
            
            // Handler for TSV format
            function handleTSVFormat(tsvText) {
                try {
                    // Parse TSV
                    const data = parseTSV(tsvText);
                    
                    // Store structured data for export
                    structuredData = data;
                    
                    // Generate table HTML
                    const tableElement = generateStructuredHTMLTable(data);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // Show format info
                    patternInfo.textContent = `Tab-Separated Format Detected`;
                    tableStructure.textContent = `${data.headers.length} columns, ${data.rows.length} data rows`;
                    
                    // Hide toggle headers button (not needed for structured formats)
                    toggleHeadersButton.classList.add('hidden');
                    
                    // Show results
                    resultSection.classList.remove('hidden');
                    
                } catch (error) {
                    showError(`Error parsing TSV: ${error.message}`);
                    return false;
                }
                return true;
            }
            
            // Handler for JSON format
            function handleJSONFormat(jsonText) {
                try {
                    // Parse JSON
                    const data = parseJSON(jsonText);
                    
                    // Store structured data for export
                    structuredData = data;
                    
                    // Generate table HTML
                    const tableElement = generateStructuredHTMLTable(data);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // Show format info
                    patternInfo.textContent = `JSON Format Detected`;
                    tableStructure.textContent = `${data.headers.length} columns, ${data.rows.length} data rows`;
                    
                    // Hide toggle headers button (not needed for structured formats)
                    toggleHeadersButton.classList.add('hidden');
                    
                    // Show results
                    resultSection.classList.remove('hidden');
                    
                } catch (error) {
                    showError(`Error parsing JSON: ${error.message}`);
                    return false;
                }
                return true;
            }
            
            // Handler for HTML format
            function handleHTMLFormat(htmlText) {
                try {
                    // Parse HTML table
                    const data = parseHTMLTable(htmlText);
                    
                    // Store structured data for export
                    structuredData = data;
                    
                    // Generate table HTML
                    const tableElement = generateStructuredHTMLTable(data);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // Show format info
                    patternInfo.textContent = `HTML Table Format Detected`;
                    tableStructure.textContent = `${data.headers.length} columns, ${data.rows.length} data rows`;
                    
                    // Hide toggle headers button (not needed for structured formats)
                    toggleHeadersButton.classList.add('hidden');
                    
                    // Show results
                    resultSection.classList.remove('hidden');
                    
                } catch (error) {
                    showError(`Error parsing HTML table: ${error.message}`);
                    return false;
                }
                return true;
            }
            
            // Handler for text format (original implementation)
            function handleTextFormat(inputText) {
                try {
                    let rawLines = inputText.split('\n');
                    // Special case for a hybrid data format, mixing tabs and new lines
                    // The tabs might not be frequent enough to trigger TSV format detection, but some lines might contain multiple tab-separated cells
                    const twoTabLines = rawLines.filter(line => 
                        (line.match(/\t/g) || []).length >= 2
                    ).length;
                    const twoTabLinesProportion = twoTabLines / rawLines.length;
                    if (twoTabLinesProportion > 0.3) {
                        rawLines = rawLines.map(line =>
                            line.split('\t')
                        ).flat();
                    }
                
                    // Split input into lines and filter out "non-useful" lines
                    const lines = rawLines.filter(line => {
                        // Count numbers in the line
                        const numericCount = (line.match(/[0-9]/g) || []).length;
                        
                        // Count letters in the line
                        const letterCount = (line.match(/[a-zA-Z]/g) || []).length;
                        
                        // Keep line if it has at least one number or at least two letters
                        return numericCount > 0 || letterCount >= 2;
                    });
                    
                    // Classify each remaining line
                    const typeSequence = lines.map(classifyCell);
                    
                    // Find the repeating pattern
                    const pattern = findRepeatingPattern(typeSequence);
                    
                    // For debugging - log all pattern candidates
                    console.log("Pattern detection analysis:");
                    
                    // Skip header rows that are typically text
                    let dataStartIndex = 0;
                    while (dataStartIndex < typeSequence.length && typeSequence[dataStartIndex] === 'T') {
                        dataStartIndex++;
                    }
                    
                    // Log sample of the data sequence for debugging
                    const dataSequence = typeSequence.slice(dataStartIndex);
                    console.log("Data sequence sample:", dataSequence.slice(0, 20).join(', '));
                    
                    // Try different patterns manually to verify
                    for (let len = 1; len <= Math.min(10, Math.floor(dataSequence.length / 3)); len++) {
                        const potentialPattern = dataSequence.slice(0, len);
                        // Calculate how much of the sequence this explains
                        let matches = 0;
                        for (let i = 0; i < dataSequence.length - len + 1; i += len) {
                            if (arraysEqual(dataSequence.slice(i, i + len), potentialPattern)) {
                                matches += len;
                            } else {
                                break;
                            }
                        }
                        
                        const coverage = (matches / dataSequence.length) * 100;
                        console.log(`Pattern of length ${len}: ${potentialPattern.join(', ')} covers ${coverage.toFixed(1)}% of data`);
                    }
                    
                    // Check for pattern validity - reject patterns that are too large or too small
                    let validPattern = pattern;
                    let patternError = null;
                    
                    if (pattern) {
                        if (pattern.length === 1) {
                            validPattern = null;
                            patternError = "Detected pattern has only 1 column per row, which is likely incorrect.";
                        } else if (pattern.length > 20) {
                            validPattern = null;
                            patternError = `Detected pattern has ${pattern.length} columns per row, which is probably too many.`;
                        }
                    } else {
                        patternError = "Could not detect a repeating pattern that covers at least 30% of the data.";
                    }
                    
                    // Show detailed error with data classification if pattern is invalid
                    if (!validPattern) {
                        showError(patternError);
                        
                        // Create visual representation of the data types sequence
                        const typeLabels = {
                            'D': 'Date',
                            'N': 'Number',
                            'T': 'Text',
                            'E': 'Empty'
                        };
                        
                        // Format the sequence with colors
                        const formattedSequence = `
                        <div class="mt-3">
                            <p class="mb-2 font-medium">Data classification sequence:</p>
                            <div class="p-2 bg-gray-100 dark:bg-gray-800 rounded text-sm overflow-x-auto">
                                ${typeSequence.slice(0, 100).map((type, i) => `
                                    <span class="inline-block px-1 py-0.5 m-0.5 rounded 
                                        ${type === 'D' ? 'bg-green-200 dark:bg-green-800' : 
                                          type === 'N' ? 'bg-blue-200 dark:bg-blue-800' : 
                                          type === 'T' ? 'bg-yellow-200 dark:bg-yellow-800' : 
                                          'bg-gray-300 dark:bg-gray-600'}">
                                        ${typeLabels[type]}
                                    </span>
                                    ${(i+1) % 10 === 0 ? '<br>' : ''}
                                `).join('')}
                                ${typeSequence.length > 100 ? '...' : ''}
                            </div>
                            <p class="mt-2 text-sm">
                                Try modifying the data or checking if there are any inconsistencies in the pattern.
                            </p>
                        </div>`;
                        
                        // Add the formatted sequence to the error message
                        errorMessage.innerHTML = patternError + formattedSequence;
                        return;
                    }
                    
                    // Organize data into a table structure
                    const tableData = organizeDataIntoTable(lines, validPattern);
                    lastTableData = tableData;
                    
                    // Check if the pattern contains a date column
                    dateColumnIndex = validPattern.indexOf('D');
                    
                    if (tableData.headers.length == tableData.pattern.length) {
                        // There are as many headers as columns, so they shouldn't need to be reordered
                        editableHeaders = false;
                    }
                    
                    // Generate the HTML table
                    const tableElement = generateHTMLTable(tableData, editableHeaders);
                    tableContainer.innerHTML = '';
                    tableContainer.appendChild(tableElement);
                    
                    // Display pattern information
                    if (validPattern) {
                        patternInfo.textContent = `Text Format - Detected Pattern: ${validPattern.join(', ')} (${validPattern.length} columns per row)`;
                        let patternDesc = validPattern.map(type => {
                            switch(type) {
                                case 'D': return 'Date';
                                case 'N': return 'Number';
                                case 'T': return 'Text';
                                case 'E': return 'Empty';
                                default: return type;
                            }
                        }).join(', ');
                        tableStructure.textContent = `Column Types: ${patternDesc}`;
                    }
                    
                    // Show toggle headers button (needed for text format) if there was ambiguity about how the header columns line up
                    if (editableHeaders) {
                        toggleHeadersButton.classList.remove('hidden');
                    }
                    
                    // Show results
                    resultSection.classList.remove('hidden');
                    
                    // Add date inputs to empty cells in the date column if needed
                    if (dateColumnIndex !== -1 && !columnSelectionEnabled) {
                        addDateInputsToEmptyCells();
                    }
                    
                } catch (error) {
                    showError(`Error parsing text data: ${error.message}`);
                    return false;
                }
                return true;
            }

            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.classList.remove('hidden');
                loadingIndicator.classList.add('hidden');
            }

            function clearData() {
                dataInput.value = '';
                structuredData = null;
                openCloseDrawer('close');
                hideInputButton.classList.add('hidden');
                errorMessage.classList.add('hidden');
                formatDetectionMessage.classList.add('hidden');
                resultSection.classList.add('hidden');
                exportOutputContainer.classList.add('hidden');
                chartContainer.classList.add('hidden');
                deleteColumnsButton.disabled = true;
                setDeleteColumnsButton('gray');
                addDateColumnButton.classList.add('hidden');
                toggleColumnsButton.disabled = false;
                dateColumnIndex = -1;
                
                // Reset sort state
                currentSortColumn = -1;
                currentSortDirection = '';
                
                // If there's an active chart, destroy it
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                
                // Also unselect any menu item from the side bar
                document.getElementById('item0').checked = true;
                
                // Put the cursor back in the initial input textarea
                dataInput.focus();
                
                // Reset the fragment if necessary
                if (window.location.hash) {
                    window.location.hash = '';
                }
            }

            // Function to display data in the output area
            function displayExportData(format) {
                // Save any date input values before exporting
                document.querySelectorAll('.date-input').forEach(input => {
                    const rowElement = input.closest('tr');
                    const cellElement = input.closest('td');
                    const rowIndex = Array.from(rowElement.parentNode.children).indexOf(rowElement);
                    const cellIndex = Array.from(rowElement.children).indexOf(cellElement);
                    
                    // Format and save the value
                    const formattedDate = parseAndFormatDate(input.value);
                    
                    // Update the data structure
                    if (currentDataFormat === 'text') {
                        if (lastTableData.dataRows[rowIndex]) {
                            lastTableData.dataRows[rowIndex][cellIndex] = formattedDate;
                        }
                    } else {
                        if (structuredData.rows[rowIndex]) {
                            structuredData.rows[rowIndex][cellIndex] = formattedDate;
                        }
                    }
                });
                
                // Make sure we save any changes in the dropdowns first
                if (editableHeaders && currentDataFormat === 'text') {
                    document.querySelectorAll('select[id^="header-select-"]').forEach(select => {
                        const columnIndex = parseInt(select.dataset.column);
                        currentHeaderSelections[columnIndex] = select.value;
                    });
                }
                
                // Set current format label
                currentExportFormat = format;
                exportFormatLabel.textContent = format;
                
                // Generate data based on format
                let outputData = '';
                if (format === 'CSV') {
                    outputData = convertToCSV();
                    closeOutputButton.textContent = 'Hide CSV';
                } else if (format === 'JSON') {
                    outputData = convertToJSON();
                    closeOutputButton.textContent = 'Hide JSON';
                }
                
                // Display in textarea
                exportOutput.value = outputData;
                exportOutputContainer.classList.remove('hidden');
                
                // Optionally scroll to the textarea
                exportOutputContainer.scrollIntoView({behavior: 'smooth'});
            }

            // Function to copy output to clipboard
            function handleCopyOutput() {
                exportOutput.select();
                document.execCommand('copy');
                
                // Show feedback
                const originalText = copyOutputButton.textContent;
                copyOutputButton.textContent = "Copied!";
                setTimeout(() => {
                    copyOutputButton.textContent = originalText;
                }, 2000);
            }

            // Function to hide output area
            function handleCloseOutput() {
                exportOutputContainer.classList.add('hidden');
            }
            
            // Listen for theme changes to update the chart
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                if (chartInstance) {
                    // Redraw the chart with the new theme
                    const isDarkMode = document.documentElement.classList.contains('dark');
                    const textColor = isDarkMode ? '#d1d5db' : '#4b5563';
                    const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                    
                    // Update chart colors
                    chartInstance.options.plugins.legend.labels.color = textColor;
                    chartInstance.options.plugins.title.color = textColor;
                    chartInstance.options.scales.x.ticks.color = textColor;
                    chartInstance.options.scales.y.ticks.color = textColor;
                    chartInstance.options.scales.x.grid.color = gridColor;
                    chartInstance.options.scales.y.grid.color = gridColor;
                    chartInstance.options.scales.x.title.color = textColor;
                    chartInstance.options.scales.y.title.color = textColor;
                    
                    // Update the chart
                    chartInstance.update();
                }
            });

            // Event listeners
            parseButton.addEventListener('click', parseData);
            clearButton.addEventListener('click', clearData);
            toggleHeadersButton.addEventListener('click', toggleHeaderMode);
            toggleColumnsButton.addEventListener('click', toggleColumnSelection);
            convertToCsvButton.addEventListener('click', () => displayExportData('CSV'));
            convertToJsonButton.addEventListener('click', () => displayExportData('JSON'));
            copyOutputButton.addEventListener('click', handleCopyOutput);
            closeOutputButton.addEventListener('click', handleCloseOutput);
            deleteColumnsButton.addEventListener('click', deleteSelectedColumns);
            
            // Also parse when pressing Ctrl+Enter in the textarea
            dataInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    parseData();
                }
            });
        });
    </script>
</body>
</html>